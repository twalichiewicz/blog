import*as THREE from"three";const DEFAULT_STATS=[{value:"$40M+",label:"ARR Impacted",detail:"Cash‑sweep flows: +18–35% conversion"},{value:"$3–5M/yr",label:"Cost Savings Delivered",detail:"Annual savings in development costs"},{value:"85%",label:"Support Tickets Reduced",detail:"Universal overlay platform rollout"}],HOLE_MAX=.42,HOLE_EXIT_MAX=.74,HOLE_EXIT_DELTA=.32,HOLE_MAX_EMBEDDED=.6,POINTER_INTERACTION={radius:.07,strength:6.2,holdMs:220,decayMs:900,maxVelocity:2.4},FLUID_SIM={maxDelta:1/30,targetScale:.78,minSize:140,maxSize:960,pressureIterations:16,vorticityStrength:14,velocityDissipation:.28,dyeDissipation:.09,noiseStrength:42,centerStrength:132,centerRadiusBase:.14},PARTICLE_TEXT={textureWidth:512,textureHeight:256,sampleLongEdge:1400,alphaThreshold:10,returnStrength:20,damping:.88,noiseStrength:.18,basePointSize:2.2,pointerStrengthMultiplier:3.1,pointerRadiusMultiplier:.85},SHADER_VERTEX="\n\tvarying vec2 vUv;\n\n\tvoid main() {\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n",SHADER_FRAGMENT="\n\tprecision highp float;\n\n\tuniform vec2 u_resolution;\n\tuniform float u_time;\n\tuniform float u_fill;\n\tuniform float u_hole;\n\tuniform sampler2D u_text;\n\tuniform float u_textAlpha;\n\tuniform sampler2D u_dye;\n\tuniform sampler2D u_velocity;\n\tuniform vec2 u_texelSize;\n\n\tvarying vec2 vUv;\n\n\tfloat hash(vec2 p) {\n\t\tp = fract(p * vec2(123.34, 456.21));\n\t\tp += dot(p, p + 45.32);\n\t\treturn fract(p.x * p.y);\n\t}\n\n\tfloat noise(vec2 p) {\n\t\tvec2 i = floor(p);\n\t\tvec2 f = fract(p);\n\t\tfloat a = hash(i);\n\t\tfloat b = hash(i + vec2(1.0, 0.0));\n\t\tfloat c = hash(i + vec2(0.0, 1.0));\n\t\tfloat d = hash(i + vec2(1.0, 1.0));\n\t\tvec2 u = f * f * (3.0 - 2.0 * f);\n\t\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\t}\n\n\tfloat fbm(vec2 p) {\n\t\tfloat value = 0.0;\n\t\tfloat amplitude = 0.5;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tvalue += amplitude * noise(p);\n\t\t\tp *= 2.02;\n\t\t\tamplitude *= 0.52;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfloat heightField(vec2 uv) {\n\t\tvec4 dye = texture2D(u_dye, clamp(uv, 0.0, 1.0));\n\t\tfloat base = dye.r * 0.72 + dye.g * 0.28;\n\t\tfloat emboss = dye.b;\n\t\treturn clamp(base + emboss * 0.34, 0.0, 1.0);\n\t}\n\n\tfloat coverageField(vec2 uv) {\n\t\treturn texture2D(u_dye, clamp(uv, 0.0, 1.0)).a;\n\t}\n\n\tvec2 velocityField(vec2 uv) {\n\t\treturn texture2D(u_velocity, clamp(uv, 0.0, 1.0)).xy;\n\t}\n\n\tvec3 metalShade(vec2 uv, float mask, float detailBoost) {\n\t\tfloat height = heightField(uv);\n\t\tfloat hx = heightField(uv + vec2(u_texelSize.x, 0.0));\n\t\tfloat hy = heightField(uv + vec2(0.0, u_texelSize.y));\n\t\tvec2 grad = vec2(hx - height, hy - height);\n\n\t\tfloat micro = fbm(uv * 42.0 + u_time * 0.06) - 0.5;\n\t\tgrad += vec2(micro) * 0.02;\n\n\t\tvec3 normal = normalize(vec3(grad * (28.0 * detailBoost), 1.0));\n\t\tvec3 viewDir = vec3(0.0, 0.0, 1.0);\n\t\tvec3 lightDir = normalize(vec3(-0.25, 0.65, 1.0));\n\n\t\tfloat diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n\t\tvec3 halfDir = normalize(lightDir + viewDir);\n\t\tfloat spec = pow(clamp(dot(normal, halfDir), 0.0, 1.0), mix(48.0, 96.0, clamp(detailBoost - 0.9, 0.0, 1.0)));\n\n\t\tfloat fresnel = pow(1.0 - clamp(dot(normal, viewDir), 0.0, 1.0), 3.0);\n\n\t\tvec3 envTop = vec3(0.98, 0.985, 1.0);\n\t\tvec3 envBot = vec3(0.22, 0.22, 0.245);\n\t\tfloat envFactor = pow(clamp(1.0 - uv.y, 0.0, 1.0), 1.15);\n\t\tvec3 env = mix(envBot, envTop, envFactor);\n\n\t\tvec3 base = vec3(0.72, 0.73, 0.76) + (height - 0.5) * 0.08;\n\t\tvec3 color = base * 0.18;\n\t\tcolor += env * (0.75 * diffuse + 0.28);\n\t\tcolor += vec3(1.0) * (spec * 1.2);\n\t\tcolor += envTop * (fresnel * 0.45);\n\t\tcolor = mix(color, envTop, spec * 0.22);\n\n\t\treturn color * mask;\n\t}\n\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec2 vel = velocityField(uv);\n\t\tvec2 shadeUv = clamp(uv + vel * u_texelSize * 0.35, 0.0, 1.0);\n\t\tfloat turbulence = heightField(shadeUv) - 0.5;\n\tfloat digitPresence = texture2D(u_dye, uv).b;\n\tfloat digitBoost = smoothstep(0.18, 0.85, digitPresence);\n\n\t\tfloat c0 = coverageField(uv);\n\t\tfloat cL = coverageField(uv - vec2(u_texelSize.x, 0.0));\n\t\tfloat cR = coverageField(uv + vec2(u_texelSize.x, 0.0));\n\t\tfloat cB = coverageField(uv - vec2(0.0, u_texelSize.y));\n\t\tfloat cT = coverageField(uv + vec2(0.0, u_texelSize.y));\n\t\tfloat cTL = coverageField(uv + vec2(-u_texelSize.x, u_texelSize.y));\n\t\tfloat cTR = coverageField(uv + vec2(u_texelSize.x, u_texelSize.y));\n\t\tfloat cBL = coverageField(uv + vec2(-u_texelSize.x, -u_texelSize.y));\n\t\tfloat cBR = coverageField(uv + vec2(u_texelSize.x, -u_texelSize.y));\n\t\tfloat cBlur = (c0 * 4.0 + (cL + cR + cB + cT) * 2.0 + (cTL + cTR + cBL + cBR)) / 16.0;\n\t\tfloat cMax = max(c0, max(max(cL, cR), max(cB, cT)));\n\t\tcMax = max(cMax, max(max(cTL, cTR), max(cBL, cBR)));\n\t\tfloat coverage = mix(cBlur, cMax, 0.26);\n\t\tfloat edge = abs(cR - cL) + abs(cT - cB);\n\t\tfloat edgeDiag = abs(cTR - cBL) + abs(cTL - cBR);\n\t\tedge = max(edge, edgeDiag * 0.85);\n\t\tfloat edgeBlend = smoothstep(0.015, 0.16, edge);\n\t\tfloat smoothCoverage = mix(coverage, cBlur, edgeBlend * (0.42 + digitBoost * 0.55));\n\t\tfloat liquidAlpha = smoothstep(0.12, 0.88, smoothCoverage);\n\t\tliquidAlpha = pow(liquidAlpha, 0.92);\n\t\tfloat glow = smoothstep(0.04, 0.18, edge) * smoothstep(0.12, 0.72, liquidAlpha);\n\n\tfloat detailBoost = 1.0 + clamp(abs(turbulence) * 1.1, 0.0, 0.45);\n\tdetailBoost += digitBoost * 0.32;\n\tvec3 outColor = metalShade(shadeUv, liquidAlpha, detailBoost);\n\toutColor = mix(outColor, outColor * 1.08 + vec3(0.04), digitBoost * liquidAlpha);\n\toutColor += glow * vec3(0.07, 0.08, 0.09);\n\n\t\tgl_FragColor = vec4(outColor, liquidAlpha);\n\t}\n",SIM_VERTEX="\n\tvarying vec2 vUv;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tgl_Position = vec4(position, 1.0);\n\t}\n",SIM_COMMON="\n\tfloat hash(vec2 p) {\n\t\tp = fract(p * vec2(123.34, 456.21));\n\t\tp += dot(p, p + 45.32);\n\t\treturn fract(p.x * p.y);\n\t}\n\n\tfloat noise(vec2 p) {\n\t\tvec2 i = floor(p);\n\t\tvec2 f = fract(p);\n\t\tfloat a = hash(i);\n\t\tfloat b = hash(i + vec2(1.0, 0.0));\n\t\tfloat c = hash(i + vec2(0.0, 1.0));\n\t\tfloat d = hash(i + vec2(1.0, 1.0));\n\t\tvec2 u = f * f * (3.0 - 2.0 * f);\n\t\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\t}\n\n\tfloat fbm(vec2 p) {\n\t\tfloat value = 0.0;\n\t\tfloat amplitude = 0.5;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvalue += amplitude * noise(p);\n\t\t\tp *= 2.08;\n\t\t\tamplitude *= 0.53;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfloat flowPotential(vec2 p) {\n\t\tfloat n = noise(p);\n\t\tn += 0.55 * noise(p * 2.12 + vec2(17.2, 9.2));\n\t\tn += 0.28 * noise(p * 4.03 - vec2(4.2, 11.7));\n\t\treturn n / 1.83;\n\t}\n\n\tvec2 curlNoise(vec2 uv, float t) {\n\t\tvec2 p = uv * 3.1 + vec2(t * 0.16, -t * 0.12);\n\t\tfloat e = 0.18;\n\t\tfloat nT = flowPotential(p + vec2(0.0, e));\n\t\tfloat nB = flowPotential(p - vec2(0.0, e));\n\t\tfloat nR = flowPotential(p + vec2(e, 0.0));\n\t\tfloat nL = flowPotential(p - vec2(e, 0.0));\n\t\tfloat dy = (nT - nB) / (2.0 * e);\n\t\tfloat dx = (nR - nL) / (2.0 * e);\n\t\treturn vec2(dy, -dx);\n\t}\n",SIM_SEED_FRAGMENT=`\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform float u_seed;\n\t${SIM_COMMON}\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat n1 = fbm(uv * 7.5 + u_seed);\n\t\tfloat n2 = fbm(uv * 11.0 - u_seed * 0.7);\n\t\tgl_FragColor = vec4(n1, n2, 0.0, 0.0);\n\t}\n`,SIM_FORCE_FRAGMENT=`\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform float u_time;\n\tuniform float u_dt;\n\tuniform float u_noiseStrength;\n\tuniform float u_centerStrength;\n\tuniform vec2 u_center;\n\tuniform float u_centerRadius;\n\tuniform vec2 u_pointer;\n\tuniform vec2 u_pointerVelocity;\n\tuniform float u_pointerRadius;\n\tuniform float u_pointerStrength;\n\tuniform float u_aspect;\n\t${SIM_COMMON}\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\n\t\tvec2 noiseForce = curlNoise(uv, u_time) * u_noiseStrength;\n\n\t\tvec2 toCenter = uv - u_center;\n\t\tvec2 toCenterScaled = vec2(toCenter.x * u_aspect, toCenter.y);\n\t\tfloat dist = length(toCenterScaled);\n\t\tfloat falloff = smoothstep(u_centerRadius, 0.0, dist);\n\t\tvec2 dir = normalize(toCenterScaled + vec2(0.0004));\n\t\tvec2 radial = dir * (u_centerStrength * falloff);\n\t\tvec2 tangential = vec2(-dir.y, dir.x) * (abs(u_centerStrength) * 0.42) * falloff * sign(u_centerStrength);\n\n\t\tvec2 pointerForce = vec2(0.0);\n\t\tif (u_pointerStrength > 0.0001) {\n\t\t\tvec2 toPointer = uv - u_pointer;\n\t\t\tvec2 pointerScaled = vec2(toPointer.x * u_aspect, toPointer.y);\n\t\t\tfloat pointerDist = length(pointerScaled);\n\t\t\tfloat pointerFalloff = smoothstep(u_pointerRadius, 0.0, pointerDist);\n\t\t\tvec2 pv = u_pointerVelocity;\n\t\t\tvec2 pvTwist = vec2(-pv.y, pv.x);\n\t\t\tfloat speed = length(pv);\n\t\t\tfloat dragAmount = smoothstep(0.02, 0.24, speed);\n\t\t\tfloat tight = pointerFalloff * pointerFalloff;\n\t\t\tvec2 dirScaled = normalize(pointerScaled + vec2(0.0004));\n\t\t\tvec2 dir = dirScaled;\n\t\t\tdir.x /= max(u_aspect, 0.0001);\n\t\t\tdir = normalize(dir);\n\t\t\tvec2 swirl = vec2(-dir.y, dir.x);\n\t\t\tvec2 pushForce = dir * (u_pointerStrength * 0.48) * tight * dragAmount;\n\t\t\tvec2 swirlForce = swirl * (u_pointerStrength * 0.32) * tight * dragAmount;\n\t\t\tvec2 dragForce = (pv * 0.92 + pvTwist * 0.35) * (u_pointerStrength * pointerFalloff);\n\t\t\tpointerForce = dragForce + pushForce + swirlForce;\n\t\t}\n\n\t\tvel += (noiseForce + radial + tangential + pointerForce) * u_dt;\n\t\tvel = clamp(vel, vec2(-10.0), vec2(10.0));\n\t\tvel *= 0.993;\n\n\t\tgl_FragColor = vec4(vel, 0.0, 1.0);\n\t}\n`,SIM_ADVECT_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform sampler2D u_source;\n\tuniform vec2 u_texelSize;\n\tuniform float u_dt;\n\tuniform float u_dissipation;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\t\tvec2 coord = uv - vel * u_texelSize * (u_dt * 1.25);\n\t\tcoord = clamp(coord, 0.0, 1.0);\n\t\tvec4 result = texture2D(u_source, coord);\n\t\tresult /= (1.0 + u_dissipation * u_dt);\n\t\tgl_FragColor = result;\n\t}\n",SIM_ADVECT_DYE_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform sampler2D u_source;\n\tuniform vec2 u_texelSize;\n\tuniform float u_dt;\n\tuniform float u_dissipation;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\t\tvec2 coord = uv - vel * u_texelSize * (u_dt * 1.25);\n\t\tcoord = clamp(coord, 0.0, 1.0);\n\t\tvec4 result = texture2D(u_source, coord);\n\t\tresult.rgb /= (1.0 + u_dissipation * u_dt);\n\t\tresult.a /= (1.0 + u_dissipation * u_dt * 0.15);\n\t\tgl_FragColor = result;\n\t}\n",SIM_DIVERGENCE_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform vec2 u_texelSize;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat L = texture2D(u_velocity, uv - vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat R = texture2D(u_velocity, uv + vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat B = texture2D(u_velocity, uv - vec2(0.0, u_texelSize.y)).y;\n\t\tfloat T = texture2D(u_velocity, uv + vec2(0.0, u_texelSize.y)).y;\n\t\tfloat div = 0.5 * (R - L + T - B);\n\t\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n\t}\n",SIM_CURL_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform vec2 u_texelSize;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat vL = texture2D(u_velocity, uv - vec2(u_texelSize.x, 0.0)).y;\n\t\tfloat vR = texture2D(u_velocity, uv + vec2(u_texelSize.x, 0.0)).y;\n\t\tfloat uB = texture2D(u_velocity, uv - vec2(0.0, u_texelSize.y)).x;\n\t\tfloat uT = texture2D(u_velocity, uv + vec2(0.0, u_texelSize.y)).x;\n\t\tfloat curl = 0.5 * (vR - vL - uT + uB);\n\t\tgl_FragColor = vec4(curl, 0.0, 0.0, 1.0);\n\t}\n",SIM_VORTICITY_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_velocity;\n\tuniform sampler2D u_curl;\n\tuniform vec2 u_texelSize;\n\tuniform float u_dt;\n\tuniform float u_strength;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat L = abs(texture2D(u_curl, uv - vec2(u_texelSize.x, 0.0)).x);\n\t\tfloat R = abs(texture2D(u_curl, uv + vec2(u_texelSize.x, 0.0)).x);\n\t\tfloat B = abs(texture2D(u_curl, uv - vec2(0.0, u_texelSize.y)).x);\n\t\tfloat T = abs(texture2D(u_curl, uv + vec2(0.0, u_texelSize.y)).x);\n\t\tfloat C = texture2D(u_curl, uv).x;\n\n\t\tvec2 grad = vec2(R - L, T - B) * 0.5;\n\t\tvec2 n = normalize(grad + vec2(0.00012));\n\t\tvec2 force = vec2(n.y, -n.x) * C * u_strength;\n\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\t\tvel += force * u_dt;\n\t\tvel = clamp(vel, vec2(-10.0), vec2(10.0));\n\t\tgl_FragColor = vec4(vel, 0.0, 1.0);\n\t}\n",SIM_CLEAR_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_texture;\n\tuniform float u_value;\n\tvoid main() {\n\t\tvec4 tex = texture2D(u_texture, vUv);\n\t\tgl_FragColor = tex * u_value;\n\t}\n",SIM_PRESSURE_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_pressure;\n\tuniform sampler2D u_divergence;\n\tuniform vec2 u_texelSize;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat L = texture2D(u_pressure, uv - vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat R = texture2D(u_pressure, uv + vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat B = texture2D(u_pressure, uv - vec2(0.0, u_texelSize.y)).x;\n\t\tfloat T = texture2D(u_pressure, uv + vec2(0.0, u_texelSize.y)).x;\n\t\tfloat div = texture2D(u_divergence, uv).x;\n\t\tfloat pressure = (L + R + B + T - div) * 0.25;\n\t\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n\t}\n",SIM_GRADIENT_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_pressure;\n\tuniform sampler2D u_velocity;\n\tuniform vec2 u_texelSize;\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tfloat L = texture2D(u_pressure, uv - vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat R = texture2D(u_pressure, uv + vec2(u_texelSize.x, 0.0)).x;\n\t\tfloat B = texture2D(u_pressure, uv - vec2(0.0, u_texelSize.y)).x;\n\t\tfloat T = texture2D(u_pressure, uv + vec2(0.0, u_texelSize.y)).x;\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\t\tvel -= vec2(R - L, T - B) * 0.5;\n\t\tgl_FragColor = vec4(vel, 0.0, 1.0);\n\t}\n",SIM_INJECT_FRAGMENT=`\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_dye;\n\tuniform float u_time;\n\tuniform float u_strength;\n\t${SIM_COMMON}\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec4 dye = texture2D(u_dye, uv);\n\t\tfloat coverage = dye.a;\n\t\tfloat digitField = dye.b;\n\t\tfloat n1 = fbm(uv * 6.0 + vec2(u_time * 0.05, -u_time * 0.03));\n\t\tfloat n2 = fbm(uv * 9.3 + vec2(-u_time * 0.04, u_time * 0.06));\n\t\tfloat n3 = fbm(uv * 14.8 + vec2(u_time * 0.02, u_time * 0.01));\n\t\tvec3 target = vec3(n1, n2, n3);\n\t\tdye.rg = mix(dye.rg, target.rg, u_strength);\n\t\tdye.b = digitField;\n\t\tdye.a = coverage;\n\t\tgl_FragColor = clamp(dye, 0.0, 1.0);\n\t}\n`,SIM_COVERAGE_FRAGMENT=`\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_dye;\n\tuniform float u_time;\n\tuniform sampler2D u_velocity;\n\tuniform sampler2D u_text;\n\tuniform vec2 u_texelSize;\n\tuniform float u_dt;\n\tuniform float u_aspect;\n\tuniform float u_fillAmount;\n\tuniform float u_fillStrength;\n\tuniform float u_holeRadius;\n\tuniform float u_holeStrength;\n\tuniform float u_holeHardness;\n\tuniform float u_textStrength;\n\t${SIM_COMMON}\n\tfloat edgeDistance(vec2 uv) {\n\t\treturn min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n\t}\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec4 dye = texture2D(u_dye, uv);\n\t\tfloat coverage = dye.a;\n\t\tfloat digitField = dye.b;\n\t\tfloat textWeightL = 1.0;\n\t\tfloat textWeightR = 1.0;\n\t\tfloat textWeightB = 1.0;\n\t\tfloat textWeightT = 1.0;\n\t\tfloat textWeightTL = 1.0;\n\t\tfloat textWeightTR = 1.0;\n\t\tfloat textWeightBL = 1.0;\n\t\tfloat textWeightBR = 1.0;\n\t\tfloat counterCut = 0.0;\n\n\t\tvec2 vel = texture2D(u_velocity, uv).xy;\n\t\tvec2 uvFlow = clamp(uv + vel * u_texelSize * 1.35, 0.0, 1.0);\n\n\t\tfloat baseNoise = fbm(uvFlow * 6.3 + vec2(u_time * 0.06, -u_time * 0.04)) - 0.5;\n\n\t\tfloat holeMask = 0.0;\n\t\tfloat holeDist = 0.0;\n\t\tfloat holeRadius = clamp(u_holeRadius, 0.0, 0.85);\n\t\tif (holeRadius > 0.001) {\n\t\t\tvec2 centerWarp = curlNoise(uvFlow * 1.35 + 0.12, u_time * 0.6) * (u_texelSize * 22.0);\n\t\t\tvec2 centered = (uvFlow - 0.5 + centerWarp) * vec2(u_aspect, 1.0);\n\t\t\tfloat dist = length(centered);\n\t\t\tholeDist = dist;\n\t\t\tfloat angle = atan(centered.y, centered.x);\n\t\t\tfloat angleNorm = angle * 0.15915494309 + 0.5;\n\t\t\tfloat angularNoise = fbm(vec2(angleNorm * 4.6, u_time * 0.06)) - 0.5;\n\t\t\tangularNoise += (fbm(vec2(angleNorm * 9.2, u_time * 0.09)) - 0.5) * 0.28;\n\n\t\t\tfloat holeWobble = baseNoise * u_holeHardness * 1.05;\n\t\t\tholeWobble += (fbm(uvFlow * 4.2 + vec2(u_time * 0.06, u_time * 0.04)) - 0.5) * u_holeHardness * 0.85;\n\t\t\tholeWobble += angularNoise * u_holeHardness * 0.65;\n\t\t\tholeWobble = clamp(holeWobble, -holeRadius * 0.34, holeRadius * 0.18);\n\t\t\tfloat radius = max(0.0, holeRadius + holeWobble);\n\t\t\tfloat holeSoft = max(0.03, 0.07 + u_holeHardness * 0.22);\n\t\t\tholeMask = 1.0 - smoothstep(radius, radius + holeSoft, dist);\n\t\t}\n\n\t\tfloat holeProtect = 1.0 - holeMask;\n\n\t\tfloat fillFront = clamp(u_fillAmount, 0.0, 1.0) * 0.62;\n\t\tfloat edgeDist = edgeDistance(uvFlow);\n\t\tfloat edgeJitter = baseNoise * 0.036 + (fbm(uvFlow * 8.4 - u_time * 0.06) - 0.5) * 0.012;\n\t\tfloat edgeSoft = 0.04 + abs(edgeJitter) * 0.8;\n\t\tfloat edgeMask = 1.0 - smoothstep(fillFront, fillFront + edgeSoft, edgeDist + edgeJitter);\n\t\tfloat fillDelta = edgeMask * u_fillStrength * u_dt;\n\t\tfillDelta *= (1.0 - holeMask * 0.98);\n\t\tcoverage = clamp(coverage + fillDelta, 0.0, 1.0);\n\n\t\tfloat textFill = clamp(u_textStrength, 0.0, 1.0);\n\t\tfloat digitMask = 0.0;\n\n\t\tif (textFill > 0.001 && holeRadius > 0.001) {\n\t\t\tvec2 textUv = uv;\n\n\t\t\tfloat rawText = clamp(texture2D(u_text, textUv).a, 0.0, 1.0);\n\t\t\tfloat rawBase = rawText;\n\t\t\tfloat tL = clamp(texture2D(u_text, textUv - vec2(u_texelSize.x, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tR = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tB = clamp(texture2D(u_text, textUv - vec2(0.0, u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat tT = clamp(texture2D(u_text, textUv + vec2(0.0, u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat tTL = clamp(texture2D(u_text, textUv + vec2(-u_texelSize.x, u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat tTR = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x, u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat tBL = clamp(texture2D(u_text, textUv + vec2(-u_texelSize.x, -u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat tBR = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x, -u_texelSize.y)).a, 0.0, 1.0);\n\t\t\tfloat blurText = (rawText * 4.0 + tL + tR + tB + tT + tTL + tTR + tBL + tBR) / 12.0;\n\t\t\tfloat neighborMax = max(max(tL, tR), max(tB, tT));\n\t\t\tneighborMax = max(neighborMax, max(max(tTL, tTR), max(tBL, tBR)));\n\t\t\tfloat bridge = smoothstep(0.58, 0.86, neighborMax) * (1.0 - smoothstep(0.08, 0.22, rawText));\n\t\t\tbridge *= smoothstep(0.18, 0.62, blurText);\n\t\t\trawText = max(rawText, blurText * bridge);\n\t\t\trawText = pow(rawText, 1.25);\n\t\t\tfloat threshold = 0.52;\n\t\t\tfloat softness = 0.035;\n\t\t\tfloat textMask = smoothstep(threshold - softness, threshold + softness, rawText);\n\t\t\tfloat textMaskSoft = smoothstep(threshold - softness * 2.2, threshold + softness * 2.2, rawText);\n\t\t\tfloat baseMask = smoothstep(threshold - softness, threshold + softness, rawBase);\n\t\t\tfloat tMaskBaseL = smoothstep(threshold - softness, threshold + softness, tL);\n\t\t\tfloat tMaskBaseR = smoothstep(threshold - softness, threshold + softness, tR);\n\t\t\tfloat tMaskBaseB = smoothstep(threshold - softness, threshold + softness, tB);\n\t\t\tfloat tMaskBaseT = smoothstep(threshold - softness, threshold + softness, tT);\n\t\t\tfloat tMaskBaseTL = smoothstep(threshold - softness, threshold + softness, tTL);\n\t\t\tfloat tMaskBaseTR = smoothstep(threshold - softness, threshold + softness, tTR);\n\t\t\tfloat tMaskBaseBL = smoothstep(threshold - softness, threshold + softness, tBL);\n\t\t\tfloat tMaskBaseBR = smoothstep(threshold - softness, threshold + softness, tBR);\n\t\t\tfloat morphMax = max(max(tMaskBaseL, tMaskBaseR), max(tMaskBaseB, tMaskBaseT));\n\t\t\tmorphMax = max(morphMax, max(max(tMaskBaseTL, tMaskBaseTR), max(tMaskBaseBL, tMaskBaseBR)));\n\t\t\tmorphMax = max(morphMax, baseMask);\n\t\t\tfloat morphMin = min(min(tMaskBaseL, tMaskBaseR), min(tMaskBaseB, tMaskBaseT));\n\t\t\tmorphMin = min(morphMin, min(min(tMaskBaseTL, tMaskBaseTR), min(tMaskBaseBL, tMaskBaseBR)));\n\t\t\tmorphMin = min(morphMin, baseMask);\n\t\t\tfloat morphBlend = smoothstep(0.35, 0.65, mix(morphMax, morphMin, 0.5));\n\t\t\tfloat textMaskMorph = mix(textMask, morphBlend, 0.6);\n\t\t\tfloat textMaskSoftMorph = mix(textMaskSoft, textMaskMorph, 0.35);\n\n\t\t\tfloat inject = clamp(u_dt * (8.5 + holeRadius * 10.0), 0.0, 1.0);\n\t\t\tdigitField = mix(digitField, textMaskMorph, inject);\n\t\t\tdigitField = clamp(digitField, 0.0, 1.0) * holeMask;\n\t\t\tdigitField *= textMaskMorph;\n\n\t\t\tfloat edgeBand = smoothstep(0.08, 0.32, textMaskSoftMorph) * (1.0 - smoothstep(0.62, 0.92, textMaskSoftMorph));\n\t\t\tvec2 rippleUv = uvFlow * 6.2 + vel * 0.1 + vec2(u_time * 0.22, -u_time * 0.19);\n\t\t\tfloat ripple = (fbm(rippleUv) - 0.5);\n\t\t\tripple += (fbm(rippleUv * 1.65 + vec2(-u_time * 0.17, u_time * 0.14)) - 0.5) * 0.7;\n\t\t\tdigitField = clamp(digitField + ripple * 0.055 * edgeBand, 0.0, 1.0);\n\t\t\tdigitField = max(digitField, textMaskMorph * 0.35);\n\t\t\tdigitField *= holeMask;\n\n\t\t\tfloat edgeNoise = (fbm(uvFlow * 2.35 + vec2(u_time * 0.16, -u_time * 0.12)) - 0.5) * 0.016;\n\t\t\tedgeNoise += (fbm(uvFlow * 4.4 + vec2(-u_time * 0.11, u_time * 0.09)) - 0.5) * 0.007;\n\t\t\tfloat edgeSoft = 0.048 + abs(edgeNoise) * 0.05;\n\t\t\tfloat outline = textMaskSoftMorph;\n\t\t\tdigitMask = smoothstep(0.5 - edgeSoft, 0.5 + edgeSoft, outline + edgeNoise) * textFill * holeMask;\n\n\t\t\tvec2 swirlUv = uvFlow * 9.2 + vel * 0.08 + vec2(u_time * 0.24, -u_time * 0.22);\n\t\t\tfloat s1 = fbm(swirlUv) - 0.5;\n\t\t\tfloat s2 = fbm(swirlUv * 1.8 + vec2(4.1, -3.7)) - 0.5;\n\t\t\tvec2 shimmer = vec2(0.52 + s1 * 0.22, 0.52 + s2 * 0.21);\n\t\t\tdye.rg = mix(dye.rg, shimmer, digitMask * 0.26);\n\n\t\t\tfloat detectThreshold = threshold - 0.09;\n\t\t\tfloat detectSoftness = softness * 1.25;\n\n\t\t\tfloat tMaskL = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tL);\n\t\t\tfloat tMaskR = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tR);\n\t\t\tfloat tMaskB = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tB);\n\t\t\tfloat tMaskT = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tT);\n\t\t\tfloat tMaskTL = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tTL);\n\t\t\tfloat tMaskTR = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tTR);\n\t\t\tfloat tMaskBL = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tBL);\n\t\t\tfloat tMaskBR = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tBR);\n\n\t\t\tfloat tL2 = clamp(texture2D(u_text, textUv - vec2(u_texelSize.x * 2.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tR2 = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x * 2.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tB2 = clamp(texture2D(u_text, textUv - vec2(0.0, u_texelSize.y * 2.0)).a, 0.0, 1.0);\n\t\t\tfloat tT2 = clamp(texture2D(u_text, textUv + vec2(0.0, u_texelSize.y * 2.0)).a, 0.0, 1.0);\n\t\t\tfloat tL4 = clamp(texture2D(u_text, textUv - vec2(u_texelSize.x * 4.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tR4 = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x * 4.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tB4 = clamp(texture2D(u_text, textUv - vec2(0.0, u_texelSize.y * 4.0)).a, 0.0, 1.0);\n\t\t\tfloat tT4 = clamp(texture2D(u_text, textUv + vec2(0.0, u_texelSize.y * 4.0)).a, 0.0, 1.0);\n\t\t\tfloat tL8 = clamp(texture2D(u_text, textUv - vec2(u_texelSize.x * 8.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tR8 = clamp(texture2D(u_text, textUv + vec2(u_texelSize.x * 8.0, 0.0)).a, 0.0, 1.0);\n\t\t\tfloat tB8 = clamp(texture2D(u_text, textUv - vec2(0.0, u_texelSize.y * 8.0)).a, 0.0, 1.0);\n\t\t\tfloat tT8 = clamp(texture2D(u_text, textUv + vec2(0.0, u_texelSize.y * 8.0)).a, 0.0, 1.0);\n\n\t\t\tfloat tMaskL2 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tL2);\n\t\t\tfloat tMaskR2 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tR2);\n\t\t\tfloat tMaskB2 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tB2);\n\t\t\tfloat tMaskT2 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tT2);\n\t\t\tfloat tMaskL4 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tL4);\n\t\t\tfloat tMaskR4 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tR4);\n\t\t\tfloat tMaskB4 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tB4);\n\t\t\tfloat tMaskT4 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tT4);\n\t\t\tfloat tMaskL8 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tL8);\n\t\t\tfloat tMaskR8 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tR8);\n\t\t\tfloat tMaskB8 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tB8);\n\t\t\tfloat tMaskT8 = smoothstep(detectThreshold - detectSoftness, detectThreshold + detectSoftness, tT8);\n\n\t\t\tfloat leftHit = max(tMaskL, max(tMaskL2, max(tMaskL4, tMaskL8)));\n\t\t\tfloat rightHit = max(tMaskR, max(tMaskR2, max(tMaskR4, tMaskR8)));\n\t\t\tfloat upHit = max(tMaskT, max(tMaskT2, max(tMaskT4, tMaskT8)));\n\t\t\tfloat downHit = max(tMaskB, max(tMaskB2, max(tMaskB4, tMaskB8)));\n\t\t\tfloat enclosed = min(min(leftHit, rightHit), min(upHit, downHit));\n\t\t\tcounterCut = (1.0 - baseMask) * smoothstep(0.48, 0.88, enclosed) * holeMask;\n\t\t\ttextWeightL = 1.0 - smoothstep(0.15, 0.55, tMaskL);\n\t\t\ttextWeightR = 1.0 - smoothstep(0.15, 0.55, tMaskR);\n\t\t\ttextWeightB = 1.0 - smoothstep(0.15, 0.55, tMaskB);\n\t\t\ttextWeightT = 1.0 - smoothstep(0.15, 0.55, tMaskT);\n\t\t\ttextWeightTL = 1.0 - smoothstep(0.15, 0.55, tMaskTL);\n\t\t\ttextWeightTR = 1.0 - smoothstep(0.15, 0.55, tMaskTR);\n\t\t\ttextWeightBL = 1.0 - smoothstep(0.15, 0.55, tMaskBL);\n\t\t\ttextWeightBR = 1.0 - smoothstep(0.15, 0.55, tMaskBR);\n\t\t}\n\n\t\tfloat digitDecay = clamp(u_dt * 3.0, 0.0, 1.0);\n\t\tdigitField = mix(digitField, 0.0, digitDecay * (1.0 - textFill));\n\t\tdigitField = clamp(digitField, 0.0, 1.0) * holeMask;\n\t\tdye.b = digitField;\n\n\t\tif (u_holeStrength > 0.0 && holeRadius > 0.001) {\n\t\t\tfloat drain = holeMask * u_holeStrength * u_dt;\n\t\t\tdrain *= (1.0 - digitMask * 0.98);\n\t\t\tcoverage = clamp(coverage - drain, 0.0, 1.0);\n\t\t}\n\n\t\tfloat background = coverage * holeProtect;\n\n\t\tfloat cL = texture2D(u_dye, uv - vec2(u_texelSize.x, 0.0)).a * textWeightL;\n\t\tfloat cR = texture2D(u_dye, uv + vec2(u_texelSize.x, 0.0)).a * textWeightR;\n\t\tfloat cB = texture2D(u_dye, uv - vec2(0.0, u_texelSize.y)).a * textWeightB;\n\t\tfloat cT = texture2D(u_dye, uv + vec2(0.0, u_texelSize.y)).a * textWeightT;\n\t\tfloat cTL = texture2D(u_dye, uv + vec2(-u_texelSize.x, u_texelSize.y)).a * textWeightTL;\n\t\tfloat cTR = texture2D(u_dye, uv + vec2(u_texelSize.x, u_texelSize.y)).a * textWeightTR;\n\t\tfloat cBL = texture2D(u_dye, uv + vec2(-u_texelSize.x, -u_texelSize.y)).a * textWeightBL;\n\t\tfloat cBR = texture2D(u_dye, uv + vec2(u_texelSize.x, -u_texelSize.y)).a * textWeightBR;\n\t\tfloat neighborMax = max(max(cL, cR), max(cB, cT));\n\t\tneighborMax = max(neighborMax, max(max(cTL, cTR), max(cBL, cBR)));\n\t\tfloat neighborAvg = (cL + cR + cB + cT + cTL + cTR + cBL + cBR) / 8.0;\n\t\tfloat closed = max(background, neighborMax * 0.985 * holeProtect);\n\t\tclosed = max(closed, neighborAvg * 0.96 * holeProtect);\n\n\t\tfloat avg = (closed * 4.0 + cL + cR + cB + cT + cTL + cTR + cBL + cBR) / 12.0;\n\t\tfloat boundary = closed * (1.0 - closed);\n\t\tfloat smoothAmt = clamp((0.28 + boundary * 0.72) * holeProtect, 0.0, 0.78);\n\t\tsmoothAmt *= (1.0 - digitMask * 0.9);\n\t\tfloat smoothed = mix(closed, avg, smoothAmt);\n\n\t\tfloat enforce = edgeMask * smoothstep(0.18, 1.0, clamp(u_fillAmount, 0.0, 1.0));\n\t\tsmoothed = max(smoothed, enforce * 0.94 * holeProtect);\n\n\t\tcoverage = max(smoothed, digitMask);\n\t\tcoverage *= (1.0 - counterCut);\n\n\t\tdye.a = clamp(coverage, 0.0, 1.0);\n\n\t\tgl_FragColor = clamp(dye, 0.0, 1.0);\n\t}\n\t`,PARTICLE_SEED_FRAGMENT="\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_target;\n\tvoid main() {\n\t\tvec4 target = texture2D(u_target, vUv);\n\t\tgl_FragColor = vec4(target.xy, 0.0, 0.0);\n\t}\n",PARTICLE_SIM_FRAGMENT=`\n\tprecision highp float;\n\tvarying vec2 vUv;\n\tuniform sampler2D u_state;\n\tuniform sampler2D u_target;\n\tuniform float u_dt;\n\tuniform float u_time;\n\tuniform float u_aspect;\n\tuniform vec2 u_pointer;\n\tuniform vec2 u_pointerVelocity;\n\tuniform float u_pointerStrength;\n\tuniform float u_pointerRadius;\n\tuniform float u_returnStrength;\n\tuniform float u_reform;\n\tuniform float u_noiseStrength;\n\t${SIM_COMMON}\n\tvoid main() {\n\t\tvec2 uv = vUv;\n\t\tvec4 target = texture2D(u_target, uv);\n\t\tfloat alive = step(0.5, target.a);\n\t\tif (alive < 0.5) {\n\t\t\tgl_FragColor = vec4(0.0);\n\t\t\treturn;\n\t\t}\n\n\t\tvec4 state = texture2D(u_state, uv);\n\t\tvec2 pos = state.xy;\n\t\tvec2 vel = state.zw;\n\n\t\tvec2 toTarget = target.xy - pos;\n\t\tfloat reform = clamp(u_reform, 0.0, 1.0);\n\t\tvel += toTarget * (u_returnStrength * reform) * u_dt;\n\n\t\tvec2 drift = curlNoise(pos * 0.55 + vec2(2.1, -1.7), u_time * 0.22);\n\t\tvel += drift * (u_noiseStrength * (0.25 + (1.0 - reform) * 0.75)) * u_dt;\n\n\t\tif (u_pointerStrength > 0.0001) {\n\t\t\tvec2 toPointer = pos - u_pointer;\n\t\t\tvec2 pointerScaled = vec2(toPointer.x * u_aspect, toPointer.y);\n\t\t\tfloat dist = length(pointerScaled);\n\t\t\tfloat falloff = smoothstep(u_pointerRadius, 0.0, dist);\n\t\t\tvec2 dir = normalize(pointerScaled + vec2(0.00001));\n\t\t\tdir.x /= max(u_aspect, 0.0001);\n\t\t\tdir = normalize(dir);\n\t\t\tvec2 swirl = vec2(-dir.y, dir.x);\n\t\t\tvec2 pv = u_pointerVelocity;\n\t\t\tfloat kick = u_pointerStrength * falloff;\n\t\t\tvel += (dir * kick + swirl * kick * 0.38 + pv * kick * 0.22) * u_dt;\n\t\t}\n\n\t\tvel *= pow(${PARTICLE_TEXT.damping.toFixed(2)}, u_dt * 60.0);\n\t\tvel = clamp(vel, vec2(-6.0), vec2(6.0));\n\t\tpos += vel * u_dt;\n\t\tpos = clamp(pos, vec2(-1.2), vec2(1.2));\n\n\t\tgl_FragColor = vec4(pos, vel);\n\t}\n`,PARTICLE_RENDER_VERTEX="\n\tprecision highp float;\n\tuniform sampler2D u_state;\n\tuniform sampler2D u_target;\n\tuniform vec2 u_resolution;\n\tuniform float u_opacity;\n\tuniform float u_pointSize;\n\tvarying float vAlpha;\n\tvarying float vSpeed;\n\tvoid main() {\n\t\tvec2 uv = position.xy;\n\t\tvec4 state = texture2D(u_state, uv);\n\t\tvec4 target = texture2D(u_target, uv);\n\t\tfloat alive = step(0.5, target.a);\n\t\tvec2 pos = state.xy;\n\t\tvec2 vel = state.zw;\n\t\tvAlpha = alive * u_opacity;\n\t\tvSpeed = length(vel);\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 0.0, 1.0);\n\t\tgl_PointSize = u_pointSize * alive;\n\t}\n",PARTICLE_MASK_VERTEX="\n\tprecision highp float;\n\tuniform sampler2D u_state;\n\tuniform sampler2D u_target;\n\tuniform float u_pointSize;\n\tvarying float vAlive;\n\tvoid main() {\n\t\tvec2 uv = position.xy;\n\t\tvec4 state = texture2D(u_state, uv);\n\t\tvec4 target = texture2D(u_target, uv);\n\t\tfloat alive = step(0.5, target.a);\n\t\tvAlive = alive;\n\t\tvec2 pos = state.xy;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 0.0, 1.0);\n\t\tgl_PointSize = u_pointSize * alive;\n\t}\n",PARTICLE_MASK_FRAGMENT="\n\tprecision highp float;\n\tvarying float vAlive;\n\tvoid main() {\n\t\tif (vAlive <= 0.001) discard;\n\t\tvec2 p = gl_PointCoord - 0.5;\n\t\tfloat r = length(p);\n\t\tif (r > 0.5) discard;\n\t\tfloat falloff = smoothstep(0.5, 0.0, r);\n\t\tfalloff = pow(falloff, 1.75);\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, falloff);\n\t}\n",PARTICLE_RENDER_FRAGMENT="\n\tprecision highp float;\n\tvarying float vAlpha;\n\tvarying float vSpeed;\n\tvoid main() {\n\t\tif (vAlpha <= 0.001) discard;\n\t\tvec2 p = gl_PointCoord - 0.5;\n\t\tfloat r = length(p) * 2.0;\n\t\tif (r > 1.0) discard;\n\t\tfloat edge = smoothstep(1.0, 0.0, r);\n\t\tedge = pow(edge, 0.65);\n\n\t\tfloat z = sqrt(max(0.0, 1.0 - r * r));\n\t\tvec3 normal = normalize(vec3(p * 2.0, z));\n\t\tvec3 viewDir = vec3(0.0, 0.0, 1.0);\n\t\tvec3 lightDir = normalize(vec3(-0.25, 0.65, 1.0));\n\n\t\tfloat diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n\t\tvec3 halfDir = normalize(lightDir + viewDir);\n\t\tfloat spec = pow(clamp(dot(normal, halfDir), 0.0, 1.0), 72.0);\n\t\tfloat fresnel = pow(1.0 - clamp(dot(normal, viewDir), 0.0, 1.0), 3.0);\n\n\t\tvec3 envTop = vec3(0.98, 0.985, 1.0);\n\t\tvec3 envBot = vec3(0.22, 0.22, 0.245);\n\t\tvec3 env = mix(envBot, envTop, clamp(normal.y * 0.5 + 0.5, 0.0, 1.0));\n\n\t\tfloat speedBoost = clamp(vSpeed * 0.15, 0.0, 0.35);\n\t\tvec3 color = vec3(0.06) + env * (0.78 * diffuse + 0.28);\n\t\tcolor += vec3(1.0) * (spec * (1.15 + speedBoost));\n\t\tcolor += envTop * (fresnel * 0.55);\n\t\tcolor = color * 1.06 + vec3(0.02);\n\n\t\tfloat alpha = clamp(edge * vAlpha * 1.28, 0.0, 1.0);\n\t\tgl_FragColor = vec4(color, alpha);\n\t}\n";function easeInOutCubic(t){return t<=0?0:t>=1?1:t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}function clamp(t,e,i){return Math.min(i,Math.max(e,t))}function normalizeWhitespace(t){return(t||"").replace(/\s+/g," ").trim()}function shortenStatValue(t){let e=normalizeWhitespace(t);return e?(e=e.replace(/\s*\/\s*yr\b/gi,"").replace(/\s*\/\s*year\b/gi,"").replace(/\bper\s+year\b/gi,"").replace(/\bMonths?\b/gi,"Mo").replace(/\bWeeks?\b/gi,"Wk").replace(/\bDays?\b/gi,"d").replace(/\bHours?\b/gi,"hr").replace(/\bMinutes?\b/gi,"m").replace(/Same[\-\u2010\u2011]day/gi,"1d"),normalizeWhitespace(e)):e}const FLOAT_TO_HALF_BUFFER=new ArrayBuffer(4),FLOAT_TO_HALF_FLOAT_VIEW=new Float32Array(FLOAT_TO_HALF_BUFFER),FLOAT_TO_HALF_INT_VIEW=new Uint32Array(FLOAT_TO_HALF_BUFFER);function floatToHalf(t){FLOAT_TO_HALF_FLOAT_VIEW[0]=t;const e=FLOAT_TO_HALF_INT_VIEW[0];let i=e>>16&32768,a=e>>12&2047,s=e>>23&255;return s<103?i:s>142?(i|=31744,255===s&&8388607&e&&(i|=1),i):s<113?(a|=2048,i|=(a>>114-s)+(a>>113-s&1),i):(i|=s-112<<10|a>>1,i+=1&a,i)}function drawTrackedText(t,e,i,a){const s=Array.from(e||"");if(!s.length)return;const n=s.map(e=>t.measureText(e).width);let r=-(n.reduce((t,e)=>t+e,0)+i*(n.length-1))/2;const o="string"==typeof a&&t[a]?a:"fillText";for(let e=0;e<s.length;e+=1)t[o](s[e],r,0),r+=n[e]+i}function resolveStats(t){return Array.isArray(t)&&t.length?t.map(t=>({value:normalizeWhitespace(t?.value),label:normalizeWhitespace(t?.label),detail:normalizeWhitespace(t?.detail)})).filter(t=>t.value):DEFAULT_STATS}class FluidSim{constructor(t){this.renderer=t,this.scene=new THREE.Scene,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2),new THREE.MeshBasicMaterial),this.scene.add(this.mesh),this.supportsLinearFiltering=t.capabilities.isWebGL2||Boolean(t.extensions?.get?.("OES_texture_half_float_linear"))||Boolean(t.extensions?.get?.("OES_texture_float_linear")),this.seedMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_SEED_FRAGMENT,uniforms:{u_seed:{value:1e3*Math.random()}}}),this.forceMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_FORCE_FRAGMENT,uniforms:{u_velocity:{value:null},u_time:{value:0},u_dt:{value:.016},u_noiseStrength:{value:FLUID_SIM.noiseStrength},u_centerStrength:{value:0},u_center:{value:new THREE.Vector2(.5,.5)},u_centerRadius:{value:.3},u_pointer:{value:new THREE.Vector2(.5,.5)},u_pointerVelocity:{value:new THREE.Vector2(0,0)},u_pointerRadius:{value:POINTER_INTERACTION.radius},u_pointerStrength:{value:0},u_aspect:{value:1}}}),this.advectMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_ADVECT_FRAGMENT,uniforms:{u_velocity:{value:null},u_source:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)},u_dt:{value:.016},u_dissipation:{value:.08}}}),this.advectDyeMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_ADVECT_DYE_FRAGMENT,uniforms:{u_velocity:{value:null},u_source:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)},u_dt:{value:.016},u_dissipation:{value:.08}}}),this.divergenceMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_DIVERGENCE_FRAGMENT,uniforms:{u_velocity:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)}}}),this.curlMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_CURL_FRAGMENT,uniforms:{u_velocity:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)}}}),this.vorticityMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_VORTICITY_FRAGMENT,uniforms:{u_velocity:{value:null},u_curl:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)},u_dt:{value:.016},u_strength:{value:FLUID_SIM.vorticityStrength}}}),this.clearMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_CLEAR_FRAGMENT,uniforms:{u_texture:{value:null},u_value:{value:0}}}),this.pressureMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_PRESSURE_FRAGMENT,uniforms:{u_pressure:{value:null},u_divergence:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)}}}),this.gradientMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_GRADIENT_FRAGMENT,uniforms:{u_pressure:{value:null},u_velocity:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)}}}),this.injectMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_INJECT_FRAGMENT,uniforms:{u_dye:{value:null},u_time:{value:0},u_strength:{value:.016}}}),this.coverageMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:SIM_COVERAGE_FRAGMENT,uniforms:{u_dye:{value:null},u_velocity:{value:null},u_text:{value:null},u_texelSize:{value:new THREE.Vector2(1/64,1/64)},u_time:{value:0},u_dt:{value:.016},u_aspect:{value:1},u_fillAmount:{value:0},u_fillStrength:{value:4.8},u_holeRadius:{value:0},u_holeStrength:{value:0},u_holeHardness:{value:.12},u_textStrength:{value:0}}}),this.resize(64,64)}get texelSize(){return this._texelSize||new THREE.Vector2(1,1)}get velocityTexture(){return this.velocity?.read?.texture||null}get dyeTexture(){return this.dye?.read?.texture||null}resize(t,e){const i=Math.max(1,Math.floor(t)),a=Math.max(1,Math.floor(e)),s=i/Math.max(a,1);this.viewAspect=s;const n=Math.floor(i*FLUID_SIM.targetScale),r=Math.floor(a*FLUID_SIM.targetScale);let o=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,n)),l=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,r));if(s>1.05?l=Math.max(FLUID_SIM.minSize,Math.round(o/s)):s<.95&&(o=Math.max(FLUID_SIM.minSize,Math.round(l*s))),o=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,o)),l=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,l)),this.forceMaterial.uniforms.u_aspect.value=this.viewAspect,this.coverageMaterial.uniforms.u_aspect.value=this.viewAspect,this.simWidth===o&&this.simHeight===l)return;this.simWidth=o,this.simHeight=l,this._texelSize=new THREE.Vector2(1/o,1/l);const h=this.supportsLinearFiltering?THREE.LinearFilter:THREE.NearestFilter,u={type:THREE.HalfFloatType,format:THREE.RGBAFormat,minFilter:h,magFilter:h,depthBuffer:!1,stencilBuffer:!1,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping},c=()=>new THREE.WebGLRenderTarget(o,l,u);this.velocity?.read?.dispose?.(),this.velocity?.write?.dispose?.(),this.dye?.read?.dispose?.(),this.dye?.write?.dispose?.(),this.pressure?.read?.dispose?.(),this.pressure?.write?.dispose?.(),this.divergence?.dispose?.(),this.curl?.dispose?.(),this.velocity={read:c(),write:c()},this.dye={read:c(),write:c()},this.pressure={read:c(),write:c()},this.divergence=c(),this.curl=c(),this.advectMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.advectDyeMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.divergenceMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.curlMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.vorticityMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.pressureMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.gradientMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.coverageMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.reset()}reset(){this.renderPass(this.seedMaterial,this.dye.read),this.renderPass(this.seedMaterial,this.dye.write),this.clearRenderTarget(this.velocity.read),this.clearRenderTarget(this.velocity.write),this.clearRenderTarget(this.pressure.read),this.clearRenderTarget(this.pressure.write),this.clearRenderTarget(this.divergence),this.clearRenderTarget(this.curl)}clearRenderTarget(t){const e=this.renderer.getRenderTarget();this.renderer.setRenderTarget(t),this.renderer.clearColor(),this.renderer.clear(!0,!0,!0),this.renderer.setRenderTarget(e)}swap(t){const e=t.read;t.read=t.write,t.write=e}renderPass(t,e){const i=this.renderer.getRenderTarget(),a=this.mesh.material;this.mesh.material=t,this.renderer.setRenderTarget(e),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(i),this.mesh.material=a}step({dt:t,time:e,centerStrength:i=0,centerRadius:a=.3,fillAmount:s=0,fillStrength:n=4.8,holeRadius:r=0,holeStrength:o=0,holeHardness:l=.12,textTexture:h=null,textStrength:u=0,pointer:c=null,pointerVelocity:d=null,pointerRadius:v=POINTER_INTERACTION.radius,pointerStrength:m=0}={}){const p=Math.min(Math.max(t||0,0),FLUID_SIM.maxDelta);if(p){this.forceMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.forceMaterial.uniforms.u_time.value=e,this.forceMaterial.uniforms.u_dt.value=p,this.forceMaterial.uniforms.u_noiseStrength.value=FLUID_SIM.noiseStrength,this.forceMaterial.uniforms.u_centerStrength.value=i,this.forceMaterial.uniforms.u_centerRadius.value=a,this.forceMaterial.uniforms.u_pointerRadius.value=v,this.forceMaterial.uniforms.u_pointerStrength.value=m,this.forceMaterial.uniforms.u_pointer.value.set(c?.x??.5,c?.y??.5),this.forceMaterial.uniforms.u_pointerVelocity.value.set(d?.vx??d?.x??0,d?.vy??d?.y??0),this.renderPass(this.forceMaterial,this.velocity.write),this.swap(this.velocity),this.advectMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.advectMaterial.uniforms.u_source.value=this.velocity.read.texture,this.advectMaterial.uniforms.u_dt.value=p,this.advectMaterial.uniforms.u_dissipation.value=FLUID_SIM.velocityDissipation,this.renderPass(this.advectMaterial,this.velocity.write),this.swap(this.velocity),this.curlMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.renderPass(this.curlMaterial,this.curl),this.vorticityMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.vorticityMaterial.uniforms.u_curl.value=this.curl.texture,this.vorticityMaterial.uniforms.u_dt.value=p,this.vorticityMaterial.uniforms.u_strength.value=FLUID_SIM.vorticityStrength,this.renderPass(this.vorticityMaterial,this.velocity.write),this.swap(this.velocity),this.divergenceMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.renderPass(this.divergenceMaterial,this.divergence),this.clearMaterial.uniforms.u_texture.value=this.pressure.read.texture,this.clearMaterial.uniforms.u_value.value=0,this.renderPass(this.clearMaterial,this.pressure.write),this.swap(this.pressure),this.pressureMaterial.uniforms.u_divergence.value=this.divergence.texture;for(let t=0;t<FLUID_SIM.pressureIterations;t+=1)this.pressureMaterial.uniforms.u_pressure.value=this.pressure.read.texture,this.renderPass(this.pressureMaterial,this.pressure.write),this.swap(this.pressure);this.gradientMaterial.uniforms.u_pressure.value=this.pressure.read.texture,this.gradientMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.renderPass(this.gradientMaterial,this.velocity.write),this.swap(this.velocity),this.advectDyeMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.advectDyeMaterial.uniforms.u_source.value=this.dye.read.texture,this.advectDyeMaterial.uniforms.u_dt.value=p,this.advectDyeMaterial.uniforms.u_dissipation.value=FLUID_SIM.dyeDissipation,this.renderPass(this.advectDyeMaterial,this.dye.write),this.swap(this.dye),this.coverageMaterial.uniforms.u_dye.value=this.dye.read.texture,this.coverageMaterial.uniforms.u_velocity.value=this.velocity.read.texture,this.coverageMaterial.uniforms.u_text.value=h,this.coverageMaterial.uniforms.u_texelSize.value.copy(this._texelSize),this.coverageMaterial.uniforms.u_time.value=e,this.coverageMaterial.uniforms.u_dt.value=p,this.coverageMaterial.uniforms.u_fillAmount.value=s,this.coverageMaterial.uniforms.u_fillStrength.value=n,this.coverageMaterial.uniforms.u_holeRadius.value=r,this.coverageMaterial.uniforms.u_holeStrength.value=o,this.coverageMaterial.uniforms.u_holeHardness.value=l,this.coverageMaterial.uniforms.u_textStrength.value=u,this.renderPass(this.coverageMaterial,this.dye.write),this.swap(this.dye),this.injectMaterial.uniforms.u_dye.value=this.dye.read.texture,this.injectMaterial.uniforms.u_time.value=e,this.injectMaterial.uniforms.u_strength.value=.006,this.renderPass(this.injectMaterial,this.dye.write),this.swap(this.dye)}}dispose(){this.velocity?.read?.dispose?.(),this.velocity?.write?.dispose?.(),this.dye?.read?.dispose?.(),this.dye?.write?.dispose?.(),this.pressure?.read?.dispose?.(),this.pressure?.write?.dispose?.(),this.divergence?.dispose?.(),this.curl?.dispose?.(),this.seedMaterial?.dispose?.(),this.forceMaterial?.dispose?.(),this.advectMaterial?.dispose?.(),this.advectDyeMaterial?.dispose?.(),this.divergenceMaterial?.dispose?.(),this.curlMaterial?.dispose?.(),this.vorticityMaterial?.dispose?.(),this.clearMaterial?.dispose?.(),this.pressureMaterial?.dispose?.(),this.gradientMaterial?.dispose?.(),this.injectMaterial?.dispose?.(),this.coverageMaterial?.dispose?.(),this.mesh?.geometry?.dispose?.(),this.mesh=null,this.scene=null,this.camera=null}}class ParticleTextSim{constructor(t){this.renderer=t,this.simWidth=PARTICLE_TEXT.textureWidth,this.simHeight=PARTICLE_TEXT.textureHeight,this.count=this.simWidth*this.simHeight,this.supportsLinearFiltering=t.capabilities.isWebGL2||Boolean(t.extensions?.get?.("OES_texture_half_float_linear"))||Boolean(t.extensions?.get?.("OES_texture_float_linear")),this.scene=new THREE.Scene,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2),new THREE.MeshBasicMaterial),this.scene.add(this.mesh);const e={type:THREE.HalfFloatType,format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,depthBuffer:!1,stencilBuffer:!1,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping},i=()=>new THREE.WebGLRenderTarget(this.simWidth,this.simHeight,e);this.state={read:i(),write:i()},this.targetData=new Uint16Array(4*this.count),this.targetTexture=new THREE.DataTexture(this.targetData,this.simWidth,this.simHeight,THREE.RGBAFormat,THREE.HalfFloatType),this.targetTexture.needsUpdate=!0,this.targetTexture.minFilter=THREE.NearestFilter,this.targetTexture.magFilter=THREE.NearestFilter,this.targetTexture.wrapS=THREE.ClampToEdgeWrapping,this.targetTexture.wrapT=THREE.ClampToEdgeWrapping,this.maskScene=new THREE.Scene,this.maskCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.maskTarget=null,this.seedMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:PARTICLE_SEED_FRAGMENT,uniforms:{u_target:{value:this.targetTexture}}}),this.simMaterial=new THREE.ShaderMaterial({vertexShader:SIM_VERTEX,fragmentShader:PARTICLE_SIM_FRAGMENT,uniforms:{u_state:{value:this.state.read.texture},u_target:{value:this.targetTexture},u_dt:{value:.016},u_time:{value:0},u_aspect:{value:1},u_pointer:{value:new THREE.Vector2(0,0)},u_pointerVelocity:{value:new THREE.Vector2(0,0)},u_pointerStrength:{value:0},u_pointerRadius:{value:.3},u_returnStrength:{value:PARTICLE_TEXT.returnStrength},u_reform:{value:1},u_noiseStrength:{value:PARTICLE_TEXT.noiseStrength}}}),this.sampleCanvas=document.createElement("canvas"),this.sampleContext=this.sampleCanvas.getContext("2d",{willReadFrequently:!0}),this.points=this.buildPoints(),this.maskPoints=this.buildMaskPoints(this.points.geometry)}get maskTexture(){return this.maskTarget?.texture||null}buildPoints(){const t=new THREE.BufferGeometry,e=new Float32Array(3*this.count);for(let t=0;t<this.count;t+=1){const i=t%this.simWidth+.5,a=Math.floor(t/this.simWidth)+.5,s=3*t;e[s]=i/this.simWidth,e[s+1]=a/this.simHeight,e[s+2]=0}t.setAttribute("position",new THREE.BufferAttribute(e,3)),this.pointsMaterial=new THREE.ShaderMaterial({vertexShader:PARTICLE_RENDER_VERTEX,fragmentShader:PARTICLE_RENDER_FRAGMENT,transparent:!0,depthTest:!1,depthWrite:!1,uniforms:{u_state:{value:this.state.read.texture},u_target:{value:this.targetTexture},u_resolution:{value:new THREE.Vector2(1,1)},u_opacity:{value:0},u_pointSize:{value:2}}}),this.pointsMaterial.blending=THREE.NormalBlending;const i=new THREE.Points(t,this.pointsMaterial);return i.frustumCulled=!1,i.renderOrder=5,i}buildMaskPoints(t){this.maskPointsMaterial=new THREE.ShaderMaterial({vertexShader:PARTICLE_MASK_VERTEX,fragmentShader:PARTICLE_MASK_FRAGMENT,transparent:!0,depthTest:!1,depthWrite:!1,uniforms:{u_state:{value:this.state.read.texture},u_target:{value:this.targetTexture},u_pointSize:{value:4}}}),this.maskPointsMaterial.blending=THREE.AdditiveBlending;const e=new THREE.Points(t,this.maskPointsMaterial);return e.frustumCulled=!1,this.maskScene.add(e),e}renderPass(t,e){const i=this.renderer.getRenderTarget(),a=this.mesh.material;this.mesh.material=t,this.renderer.setRenderTarget(e),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(i),this.mesh.material=a}swap(t){const e=t.read;t.read=t.write,t.write=e}seed(){this.seedMaterial.uniforms.u_target.value=this.targetTexture,this.renderPass(this.seedMaterial,this.state.read),this.renderPass(this.seedMaterial,this.state.write),this.pointsMaterial.uniforms.u_state.value=this.state.read.texture,this.maskPointsMaterial.uniforms.u_state.value=this.state.read.texture}renderMask(){if(!this.maskTarget)return;const t=this.renderer.getRenderTarget();this.renderer.setRenderTarget(this.maskTarget),this.renderer.clearColor(),this.renderer.clear(!0,!0,!0),this.renderer.render(this.maskScene,this.maskCamera),this.renderer.setRenderTarget(t)}resize(t,e,i=1){const a=Math.max(1,Math.floor(t)),s=Math.max(1,Math.floor(e)),n=a/Math.max(s,1);this.simMaterial.uniforms.u_aspect.value=n,this.pointsMaterial.uniforms.u_resolution.value.set(a,s);const r=clamp(i||1,1,2),o=clamp(Math.min(a,s)/360,.95,1.4);this.pointsMaterial.uniforms.u_pointSize.value=PARTICLE_TEXT.basePointSize*o*r;const l=Math.floor(a*FLUID_SIM.targetScale),h=Math.floor(s*FLUID_SIM.targetScale);let u=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,l)),c=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,h));if(n>1.05?c=Math.max(FLUID_SIM.minSize,Math.round(u/n)):n<.95&&(u=Math.max(FLUID_SIM.minSize,Math.round(c*n))),u=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,u)),c=Math.max(FLUID_SIM.minSize,Math.min(FLUID_SIM.maxSize,c)),!this.maskTarget||this.maskTarget.width!==u||this.maskTarget.height!==c){this.maskTarget?.dispose?.();const t=this.supportsLinearFiltering?THREE.LinearFilter:THREE.NearestFilter;this.maskTarget=new THREE.WebGLRenderTarget(u,c,{type:THREE.HalfFloatType,format:THREE.RGBAFormat,minFilter:t,magFilter:t,depthBuffer:!1,stencilBuffer:!1,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping})}const d=clamp(Math.min(u,c)/175*r,1.55,5.6);this.maskPointsMaterial.uniforms.u_pointSize.value=d,this.renderMask()}setTargetsFromCanvas(t){if(!this.sampleContext||!t)return;const e=Math.max(1,t.width),i=Math.max(1,t.height),a=e/i,s=PARTICLE_TEXT.sampleLongEdge,n=a>=1?s:Math.max(1,Math.round(s*a)),r=a>=1?Math.max(1,Math.round(s/a)):s;this.sampleCanvas.width===n&&this.sampleCanvas.height===r||(this.sampleCanvas.width=n,this.sampleCanvas.height=r),this.sampleContext.clearRect(0,0,n,r),this.sampleContext.drawImage(t,0,0,e,i,0,0,n,r);const o=this.sampleContext.getImageData(0,0,n,r).data,l=PARTICLE_TEXT.alphaThreshold;this.targetData.fill(0);let h=0,u=0;for(let t=0;t<r;t+=1)for(let e=0;e<n;e+=1){if(o[4*(t*n+e)+3]<l)continue;u+=1;let i=-1;if(h<this.count)i=h,h+=1;else{const t=Math.floor(Math.random()*u);if(t>=this.count)continue;i=t}const a=.75,s=clamp(e+.5+(Math.random()-.5)*a,.5,n-.5)/n*2-1,c=-(clamp(t+.5+(Math.random()-.5)*a,.5,r-.5)/r*2-1),d=4*i;this.targetData[d]=floatToHalf(s),this.targetData[d+1]=floatToHalf(c),this.targetData[d+2]=floatToHalf(0),this.targetData[d+3]=floatToHalf(1)}0===h&&(this.targetData[3]=floatToHalf(1)),this.targetTexture.needsUpdate=!0,this.seed(),this.renderMask()}step({dt:t,time:e,pointer:i=null,pointerVelocity:a=null,pointerRadius:s=.3,pointerStrength:n=0,opacity:r=0,reform:o=1}={}){const l=Math.min(Math.max(t||0,0),FLUID_SIM.maxDelta);if(this.pointsMaterial.uniforms.u_opacity.value=clamp(r,0,1),!l)return;this.simMaterial.uniforms.u_state.value=this.state.read.texture,this.simMaterial.uniforms.u_target.value=this.targetTexture,this.simMaterial.uniforms.u_dt.value=l,this.simMaterial.uniforms.u_time.value=e;const h=i?.x??.5,u=i?.y??.5;this.simMaterial.uniforms.u_pointer.value.set(2*h-1,2*u-1);const c=a?.vx??a?.x??0,d=a?.vy??a?.y??0;this.simMaterial.uniforms.u_pointerVelocity.value.set(2*c,2*d),this.simMaterial.uniforms.u_pointerStrength.value=n,this.simMaterial.uniforms.u_pointerRadius.value=2*s,this.simMaterial.uniforms.u_reform.value=clamp(o,0,1),this.renderPass(this.simMaterial,this.state.write),this.swap(this.state),this.pointsMaterial.uniforms.u_state.value=this.state.read.texture,this.maskPointsMaterial.uniforms.u_state.value=this.state.read.texture,this.renderMask()}dispose(){this.state?.read?.dispose?.(),this.state?.write?.dispose?.(),this.maskTarget?.dispose?.(),this.targetTexture?.dispose?.(),this.seedMaterial?.dispose?.(),this.simMaterial?.dispose?.(),this.maskPointsMaterial?.dispose?.(),this.pointsMaterial?.dispose?.(),this.maskScene=null,this.maskCamera=null,this.maskTarget=null,this.points?.geometry?.dispose?.(),this.mesh?.geometry?.dispose?.(),this.mesh=null,this.scene=null,this.camera=null,this.points=null}}class ImpactLiquidOverlay{constructor({stats:t,closeAnchor:e,onRequestClose:i,mountTarget:a,coveredTarget:s,applyChromeTint:n}={}){this.stats=resolveStats(t),this.closeAnchor=e||null,this.onRequestClose="function"==typeof i?i:null,this.mountTarget=a&&1===a.nodeType?a:document.body,this.coveredTarget=s&&1===s.nodeType?s:document.body,this.applyChromeTintOnMount=!1!==n,this.isEmbedded=this.mountTarget&&this.mountTarget!==document.body,this.holeMax=.42,this.holeExitMax=.74,this.activeIndex=0,this.captionVisible=!1,this.autoAdvanceMs=18e3,this.autoAdvanceElapsed=0,this.autoAdvanceLastTick=null,this.hasInteracted=!1,this.lastPhase=null,this.themeColorNodes=null,this.themeColorValues=null,this.prevHtmlBg=null,this.prevBodyBg=null,this.chromeTintApplied=!1,this.phase="enter-fill",this.phaseStart=performance.now(),this.fill=0,this.hole=0,this.textAlpha=0,this.isExiting=!1,this.isCovered=!1,this.exitHoleStart=null,this.pointer={isDown:!1,x:.5,y:.5,vx:0,vy:0,lastX:.5,lastY:.5,lastTime:null,lastMoveTime:null,pointerId:null},this.pointerDown=null,this.lastFrame=null,this.particlePointerVelocity={vx:0,vy:0},this.handleResize=this.handleResize.bind(this),this.handlePointerDown=this.handlePointerDown.bind(this),this.handlePointerMove=this.handlePointerMove.bind(this),this.handlePointerEnter=this.handlePointerEnter.bind(this),this.handlePointerUp=this.handlePointerUp.bind(this),this.handlePointerCancel=this.handlePointerCancel.bind(this),this.handleTouchMove=this.handleTouchMove.bind(this),this.animate=this.animate.bind(this),this.handleKeydown=this.handleKeydown.bind(this)}setCoveredState(t){const e=Boolean(t);this.isCovered!==e&&(this.isCovered=e,this.root&&this.root.classList.toggle("is-covered",e),this.coveredTarget?.classList?this.coveredTarget.classList.toggle("impact-liquid-covered",e):"undefined"!=typeof document&&document.body&&document.body.classList.toggle("impact-liquid-covered",e))}mount(){if(this.root&&document.contains(this.root))return;const t=this.mountTarget&&document.contains(this.mountTarget)?this.mountTarget:document.body;if(this.mountTarget=t,this.isEmbedded=this.mountTarget&&this.mountTarget!==document.body,this.root=document.createElement("div"),this.root.className="impact-liquid-overlay",this.isEmbedded&&this.root.classList.add("is-embedded"),this.root.setAttribute("aria-hidden","false"),this.root.setAttribute("role","presentation"),this.canvas=document.createElement("canvas"),this.canvas.className="impact-liquid-canvas",this.root.appendChild(this.canvas),!this.isEmbedded&&(this.closeButton=document.createElement("button"),this.closeButton.type="button",this.closeButton.className="impact-liquid-close",this.closeButton.setAttribute("aria-label","Close stats"),this.closeButton.innerHTML='\n\t\t\t\t<span class="impact-liquid-close-icon" aria-hidden="true">\n\t\t\t\t\t<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" focusable="false">\n\t\t\t\t\t\t<path fill="currentColor" d="M6.4 5.3L5.3 6.4 10.9 12 5.3 17.6l1.1 1.1L12 13.1l5.6 5.6 1.1-1.1L13.1 12l5.6-5.6-1.1-1.1L12 10.9 6.4 5.3z"/>\n\t\t\t\t\t</svg>\n\t\t\t\t</span>\n\t\t\t\t<span class="impact-liquid-close-text" aria-hidden="true">Close</span>\n\t\t\t',this.closeButton.addEventListener("pointerdown",t=>t.stopPropagation()),this.closeButton.addEventListener("pointerup",t=>t.stopPropagation()),this.closeButton.addEventListener("click",t=>{t.stopPropagation(),this.requestClose()}),this.root.appendChild(this.closeButton),this.closeAnchor)){const{top:t,left:e,collapsedWidth:i,expandedWidth:a,height:s}=this.closeAnchor;Number.isFinite(t)&&(this.closeButton.style.top=`${t}px`),Number.isFinite(e)&&(this.closeButton.style.left=`${e}px`,this.closeButton.style.right="auto"),Number.isFinite(i)&&this.closeButton.style.setProperty("--impact-liquid-close-collapsed-width",`${i}px`),Number.isFinite(a)&&this.closeButton.style.setProperty("--impact-liquid-close-expanded-width",`${a}px`),Number.isFinite(s)&&(this.closeButton.style.height=`${s}px`)}this.caption=document.createElement("div"),this.caption.className="impact-liquid-caption",this.caption.setAttribute("aria-live","polite"),this.caption.innerHTML='\n\t\t\t<div class="impact-liquid-caption-inner">\n\t\t\t\t<div class="impact-liquid-caption-label"></div>\n\t\t\t\t<div class="impact-liquid-caption-detail"></div>\n\t\t\t\t<div class="impact-liquid-caption-progress" aria-hidden="true">\n\t\t\t\t\t<svg viewBox="0 0 36 36">\n\t\t\t\t\t\t<circle class="impact-liquid-caption-progress-track" cx="18" cy="18" r="15"></circle>\n\t\t\t\t\t\t<circle class="impact-liquid-caption-progress-value" cx="18" cy="18" r="15"></circle>\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t',this.root.appendChild(this.caption),this.setCaptionVisible(!1),t.appendChild(this.root),this.setCoveredState(!1),this.applyChromeTintOnMount&&this.applyChromeTint("rgb(0, 0, 0)"),this.root.addEventListener("pointerdown",this.handlePointerDown),this.root.addEventListener("pointermove",this.handlePointerMove),this.root.addEventListener("pointerenter",this.handlePointerEnter),this.root.addEventListener("pointerup",this.handlePointerUp),this.root.addEventListener("pointercancel",this.handlePointerCancel),this.root.addEventListener("touchmove",this.handleTouchMove,{passive:!1}),window.addEventListener("resize",this.handleResize),window.addEventListener("orientationchange",this.handleResize),window.addEventListener("keydown",this.handleKeydown),this.initThree(),this.setStat(0),this.handleResize(),requestAnimationFrame(()=>{this.closeButton&&this.closeButton.classList.add("is-expanded")}),this.phase="enter-fill",this.phaseStart=performance.now(),this.running=!0,this.animationFrame=requestAnimationFrame(this.animate)}initThree(){this.scene=new THREE.Scene,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.renderer=new THREE.WebGLRenderer({canvas:this.canvas,alpha:!0,antialias:!0,powerPreference:"high-performance"}),this.renderer.setClearColor(0,0),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,1.6)),this.fluid=new FluidSim(this.renderer),this.textCanvas=document.createElement("canvas"),this.textContext=this.textCanvas.getContext("2d"),this.textTexture=new THREE.CanvasTexture(this.textCanvas),this.textTexture.minFilter=THREE.LinearFilter,this.textTexture.magFilter=THREE.LinearFilter,this.textTexture.wrapS=THREE.ClampToEdgeWrapping,this.textTexture.wrapT=THREE.ClampToEdgeWrapping,this.textTexture.colorSpace=THREE.SRGBColorSpace,this.uniforms={u_resolution:{value:new THREE.Vector2(1,1)},u_time:{value:0},u_fill:{value:0},u_hole:{value:0},u_text:{value:this.textTexture},u_textAlpha:{value:0},u_dye:{value:this.fluid.dyeTexture},u_velocity:{value:this.fluid.velocityTexture},u_texelSize:{value:this.fluid.texelSize.clone()}},this.material=new THREE.ShaderMaterial({transparent:!0,depthTest:!1,depthWrite:!1,uniforms:this.uniforms,vertexShader:SHADER_VERTEX,fragmentShader:SHADER_FRAGMENT}),this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2),this.material),this.scene.add(this.mesh),this.particleText=new ParticleTextSim(this.renderer)}getViewportRect(){if(this.root){const t=this.root.getBoundingClientRect();if(t.width&&t.height)return t}if(this.mountTarget&&this.mountTarget!==document.body){const t=this.mountTarget.getBoundingClientRect();if(t.width&&t.height)return t}return{left:0,top:0,width:window.innerWidth||1,height:window.innerHeight||1}}handleResize(){if(!this.renderer||!this.uniforms)return;const t=this.getViewportRect(),e=Math.max(1,Math.floor(t.width)),i=Math.max(1,Math.floor(t.height));this.updateHoleTargets(e),this.renderer.setSize(e,i,!1),this.uniforms.u_resolution.value.set(e,i),this.particleText?.resize(e,i,this.renderer.getPixelRatio()),this.fluid&&(this.fluid.resize(e,i),this.uniforms.u_dye.value=this.fluid.dyeTexture,this.uniforms.u_velocity.value=this.fluid.velocityTexture,this.uniforms.u_texelSize.value.copy(this.fluid.texelSize)),this.resizeTextCanvas(e,i),this.redrawText()}updateHoleTargets(t){const e=this.isEmbedded&&t>768?.6:.42;this.holeMax=e,this.holeExitMax=Math.min(.92,e+.32)}resizeTextCanvas(t,e){const i=Math.min(window.devicePixelRatio||1,2),a=Math.max(t,e),s=clamp(Math.floor(a*i),900,1400)/Math.max(1,a),n=Math.max(1,Math.round(t*s)),r=Math.max(1,Math.round(e*s));this.textCanvas.width===n&&this.textCanvas.height===r||(this.textCanvas.width=n,this.textCanvas.height=r,this.textTexture.needsUpdate=!0)}setStat(t){const e=(t%this.stats.length+this.stats.length)%this.stats.length;this.activeIndex=e;const i=this.stats[this.activeIndex],a=this.caption?.querySelector(".impact-liquid-caption-label"),s=this.caption?.querySelector(".impact-liquid-caption-detail"),n=Boolean(i.detail);this.caption&&this.caption.classList.toggle("has-detail",n),a&&(a.textContent=i.label||""),s&&(s.textContent=i.detail||""),this.currentValue=shortenStatValue(i.value)||i.value,this.currentLabel=i.label,this.redrawText()}setCaptionVisible(t){const e=Boolean(t);this.captionVisible!==e&&(this.captionVisible=e,this.caption&&this.caption.classList.toggle("is-fading",!e))}setAutoAdvanceProgress(t){this.caption&&this.caption.style.setProperty("--impact-progress",t.toFixed(3))}registerInteraction(t=performance.now()){this.hasInteracted||(this.hasInteracted=!0,this.autoAdvanceElapsed=0,this.autoAdvanceLastTick=t)}handlePointerEnter(t){"mouse"===t.pointerType&&this.registerInteraction()}ensureThemeColorNodes(){if(this.themeColorNodes)return;const t=Array.from(document.querySelectorAll('meta[name="theme-color"]'));if(!t.length&&document.head){const e=getComputedStyle(document.body||document.documentElement).backgroundColor||"rgb(0, 0, 0)",i=document.createElement("meta");i.setAttribute("name","theme-color"),i.setAttribute("content",e),document.head.appendChild(i),t.push(i)}this.themeColorNodes=t,this.themeColorValues=t.map(t=>t.getAttribute("content"))}applyChromeTint(t){this.chromeTintApplied||(this.ensureThemeColorNodes(),this.themeColorNodes?.length&&this.themeColorNodes.forEach(e=>e.setAttribute("content",t)),document.documentElement&&(this.prevHtmlBg=document.documentElement.style.backgroundColor,document.documentElement.style.backgroundColor=t),document.body&&(this.prevBodyBg=document.body.style.backgroundColor,document.body.style.backgroundColor=t),this.chromeTintApplied=!0)}restoreChromeTint(){this.chromeTintApplied&&(this.themeColorNodes?.length&&this.themeColorValues&&this.themeColorNodes.forEach((t,e)=>{const i=this.themeColorValues[e];null==i?t.removeAttribute("content"):t.setAttribute("content",i)}),document.documentElement&&(document.documentElement.style.backgroundColor=this.prevHtmlBg||""),document.body&&(document.body.style.backgroundColor=this.prevBodyBg||""),this.chromeTintApplied=!1)}redrawText(){if(!this.textContext||!this.textCanvas)return;const t=this.textContext,{width:e,height:i}=this.textCanvas;t.clearRect(0,0,e,i),t.save(),t.translate(e/2,i/2),t.textAlign="left",t.textBaseline="alphabetic";const a=this.currentValue||"",s=Array.from(a).length,n=.9*e;let r=Math.floor(.42*Math.min(e,i));r=clamp(r,72,320);const o=t=>`900 ${t}px Impact, Haettenschweiler, "Arial Narrow Bold", "Arial Narrow", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;for(t.font=o(r);r>42&&!(t.measureText(a).width<=n);)r-=6,t.font=o(r);const l=t.font;let h=clamp(.035*r,0,18);if(s>2){const e=t.measureText(a).width+h*Math.max(0,s-1);e>n&&(h=clamp(h*(n/e),0,18))}const u=t.measureText(a),c=u.actualBoundingBoxAscent??.78*r,d=-(c+(u.actualBoundingBoxDescent??.22*r)+0)/2+c;t.fillStyle="#ffffff",t.lineJoin="round",t.miterLimit=2,t.save(),t.translate(0,d),t.font=l,drawTrackedText(t,a,h,"fillText"),t.strokeStyle="rgba(255, 255, 255, 0.92)",t.lineWidth=clamp(.032*r,1.5,7),drawTrackedText(t,a,h,"strokeText"),t.restore(),t.restore(),this.textTexture.needsUpdate=!0,this.particleText?.setTargetsFromCanvas(this.textCanvas)}handlePointerDown(t){if(this.pointer&&this.pointer.isDown&&this.pointer.pointerId!==t.pointerId)return;const e=this.getViewportRect(),i=Math.max(1,e.width||1),a=Math.max(1,e.height||1),s=clamp((t.clientX-e.left)/i,0,1),n=clamp(1-(t.clientY-e.top)/a,0,1);this.pointer.isDown=!0,this.pointer.pointerId=t.pointerId,this.pointer.x=s,this.pointer.y=n,this.pointer.lastX=s,this.pointer.lastY=n,this.pointer.vx=0,this.pointer.vy=0,this.pointer.lastTime=performance.now(),this.pointer.lastMoveTime=performance.now(),this.registerInteraction();try{this.root?.setPointerCapture?.(t.pointerId)}catch(t){}this.pointerDown={x:t.clientX,y:t.clientY,time:performance.now()}}handlePointerMove(t){if(!this.pointer?.isDown)return;if(null!=this.pointer.pointerId&&t.pointerId!==this.pointer.pointerId)return;const e=this.getViewportRect(),i=Math.max(1,e.width||1),a=Math.max(1,e.height||1),s=performance.now(),n=clamp((t.clientX-e.left)/i,0,1),r=clamp(1-(t.clientY-e.top)/a,0,1),o=this.pointer.lastTime??s,l=Math.max((s-o)/1e3,.001),h=clamp((n-this.pointer.lastX)/l,-POINTER_INTERACTION.maxVelocity,POINTER_INTERACTION.maxVelocity),u=clamp((r-this.pointer.lastY)/l,-POINTER_INTERACTION.maxVelocity,POINTER_INTERACTION.maxVelocity);this.pointer.x=n,this.pointer.y=r,this.pointer.vx=h,this.pointer.vy=u,this.pointer.lastX=n,this.pointer.lastY=r,this.pointer.lastTime=s,this.pointer.lastMoveTime=s,this.registerInteraction(s)}handlePointerUp(t){if(this.pointer?.isDown&&(null==this.pointer.pointerId||t.pointerId===this.pointer.pointerId)){this.pointer.isDown=!1,this.pointer.pointerId=null,this.pointer.lastTime=performance.now(),this.pointer.lastMoveTime=performance.now();try{this.root?.releasePointerCapture?.(t.pointerId)}catch(t){}}if(!this.pointerDown)return;const e=t.clientX-this.pointerDown.x,i=t.clientY-this.pointerDown.y,a=Math.hypot(e,i),s=performance.now()-this.pointerDown.time;this.pointerDown=null,a>14||s>800||this.advance()}handlePointerCancel(t){this.pointer?.isDown&&(null!=this.pointer.pointerId&&t.pointerId!==this.pointer.pointerId||(this.pointer.isDown=!1,this.pointer.pointerId=null,this.pointer.vx=0,this.pointer.vy=0,this.pointer.lastTime=performance.now(),this.pointer.lastMoveTime=performance.now())),this.pointerDown=null}handleTouchMove(t){t.preventDefault()}handleKeydown(t){"Escape"===t.key&&this.requestClose()}advance(){this.isExiting||"show-stat"===this.phase&&(this.phase="cycle-close",this.phaseStart=performance.now(),this.nextIndex=(this.activeIndex+1)%this.stats.length)}requestClose(){this.isExiting||(this.setCoveredState(!1),this.isExiting=!0,this.exitHoleStart=this.hole,this.closeButton&&this.closeButton.classList.remove("is-expanded"),this.phase="exit",this.phaseStart=performance.now(),this.onRequestClose&&this.onRequestClose())}animate(t){if(!this.running||!this.renderer||!this.uniforms)return;const e=this.lastFrame??t,i=Math.min(Math.max((t-e)/1e3,0),FLUID_SIM.maxDelta);this.lastFrame=t;const a=t-this.phaseStart;if("enter-fill"===this.phase){const e=easeInOutCubic(clamp(a/760,0,1));this.fill=1,this.hole=(1-e)*this.holeMax,this.textAlpha=0,e>=1&&(this.setCoveredState(!0),this.phase="enter-fill-delay",this.phaseStart=t)}else if("enter-fill-delay"===this.phase)this.fill=1,this.hole=0,this.textAlpha=0,a>=260&&(this.phase="enter-reveal",this.phaseStart=t);else if("enter-reveal"===this.phase){const e=easeInOutCubic(clamp(a/920,0,1));this.fill=1,this.hole=e*this.holeMax,this.textAlpha=clamp((e-.22)/.78,0,1),e>=1&&(this.phase="show-stat",this.phaseStart=t)}else if("cycle-close"===this.phase){const e=easeInOutCubic(clamp(a/520,0,1));this.fill=1,this.hole=(1-e)*this.holeMax,this.textAlpha=clamp(1-1.2*e,0,1),e>=1&&(this.phase="cycle-delay",this.phaseStart=t,this.setStat(this.nextIndex))}else if("cycle-delay"===this.phase)this.fill=1,this.hole=0,this.textAlpha=0,a>=240&&(this.phase="enter-reveal",this.phaseStart=t);else if("exit"===this.phase){const t=easeInOutCubic(clamp(a/760,0,1));this.textAlpha=0;const e=Number.isFinite(this.exitHoleStart)?this.exitHoleStart:this.hole;if(this.hole=e+(this.holeExitMax-e)*t,this.fill=1,t>=1)return void this.dispose()}let s=0;if(this.hasInteracted&&"show-stat"===this.phase){null==this.autoAdvanceLastTick&&(this.autoAdvanceLastTick=t),this.phase!==this.lastPhase&&(this.autoAdvanceElapsed=0,this.autoAdvanceLastTick=t);const e=this.pointer?.isDown;if(e)this.autoAdvanceLastTick=t;else{const e=Math.max(0,t-this.autoAdvanceLastTick);this.autoAdvanceElapsed=Math.min(this.autoAdvanceElapsed+e,this.autoAdvanceMs),this.autoAdvanceLastTick=t,this.autoAdvanceElapsed>=this.autoAdvanceMs&&(this.autoAdvanceElapsed=0,this.advance())}s=clamp(this.autoAdvanceElapsed/this.autoAdvanceMs,0,1)}else null!=this.autoAdvanceLastTick&&(this.autoAdvanceLastTick=t);this.setAutoAdvanceProgress(s),this.lastPhase=this.phase;const n="show-stat"===this.phase||"enter-reveal"===this.phase&&this.textAlpha>.18;if(this.setCaptionVisible(n),this.uniforms.u_time.value=t/1e3,this.uniforms.u_fill.value=this.fill,this.uniforms.u_hole.value=this.hole,this.uniforms.u_textAlpha.value=this.textAlpha,this.fluid){const e=t/1e3;let a=0,s=5.2,n=0;"enter-fill"===this.phase?(a=1.05*-FLUID_SIM.centerStrength,s=7.4,n=0):"enter-reveal"===this.phase?(a=FLUID_SIM.centerStrength,n=8.5):"show-stat"===this.phase?(a=.32*FLUID_SIM.centerStrength,n=5.4):"cycle-close"===this.phase?(a=1.05*-FLUID_SIM.centerStrength,n=0):"cycle-delay"===this.phase?(a=.45*-FLUID_SIM.centerStrength,n=0):"exit"===this.phase&&(a=FLUID_SIM.centerStrength,n=9.2);const r=Math.max(0,this.hole),o=Math.max(FLUID_SIM.centerRadiusBase,1.05*r),l=.06+.28*r;let h=0,u=0,c=POINTER_INTERACTION.radius;if(null!=this.pointer?.lastMoveTime){const e=t-this.pointer.lastMoveTime;let i=0;i=e<=POINTER_INTERACTION.holdMs?1:clamp(1-(e-POINTER_INTERACTION.holdMs)/POINTER_INTERACTION.decayMs,0,1),h=i,u=POINTER_INTERACTION.strength*i,c=POINTER_INTERACTION.radius*(.92+.18*i)}this.fluid.step({dt:i,time:e,centerStrength:a,centerRadius:o,fillAmount:this.fill,fillStrength:s,holeRadius:r,holeStrength:n,holeHardness:l,textTexture:this.particleText?.maskTexture||this.textTexture,textStrength:this.textAlpha,pointer:this.pointer,pointerVelocity:this.pointer,pointerRadius:1.05*c,pointerStrength:1.55*u}),this.uniforms.u_dye.value=this.fluid.dyeTexture,this.uniforms.u_velocity.value=this.fluid.velocityTexture,this.uniforms.u_texelSize.value.copy(this.fluid.texelSize);const d=clamp(1-(null!=this.pointer?.lastMoveTime?t-this.pointer.lastMoveTime:1/0)/180,0,1),v=clamp(Math.hypot(this.pointer?.vx??0,this.pointer?.vy??0)/(.7*POINTER_INTERACTION.maxVelocity),0,1),m=clamp(1-d*v*.75,.25,1),p=this.particlePointerVelocity;p.vx=(this.pointer?.vx??0)*d,p.vy=(this.pointer?.vy??0)*d,this.particleText?.step({dt:i,time:e,pointer:this.pointer,pointerVelocity:p,pointerRadius:c*PARTICLE_TEXT.pointerRadiusMultiplier,pointerStrength:u*PARTICLE_TEXT.pointerStrengthMultiplier,opacity:this.textAlpha,reform:m})}this.renderer.render(this.scene,this.camera),this.animationFrame=requestAnimationFrame(this.animate)}dispose(){this.running=!1,this.animationFrame&&(cancelAnimationFrame(this.animationFrame),this.animationFrame=null),this.root?.removeEventListener("pointerdown",this.handlePointerDown),this.root?.removeEventListener("pointermove",this.handlePointerMove),this.root?.removeEventListener("pointerenter",this.handlePointerEnter),this.root?.removeEventListener("pointerup",this.handlePointerUp),this.root?.removeEventListener("pointercancel",this.handlePointerCancel),this.root?.removeEventListener("touchmove",this.handleTouchMove),window.removeEventListener("resize",this.handleResize),window.removeEventListener("orientationchange",this.handleResize),window.removeEventListener("keydown",this.handleKeydown),this.mesh&&(this.mesh.geometry?.dispose(),this.material?.dispose()),this.textTexture?.dispose(),this.particleText?.dispose?.(),this.fluid?.dispose?.(),this.renderer?.dispose(),this.scene=null,this.camera=null,this.mesh=null,this.material=null,this.particleText=null,this.renderer=null,this.uniforms=null,this.setCoveredState(!1),this.applyChromeTintOnMount&&this.restoreChromeTint(),this.root?.parentElement&&this.root.parentElement.removeChild(this.root),this.root=null}}let overlay=null;export function startImpactLiquidOverlay(t={}){return overlay||(overlay=new ImpactLiquidOverlay(t),overlay.mount(),overlay)}export function stopImpactLiquidOverlay(){return overlay?(overlay.closeButton&&overlay.closeButton.classList.remove("is-expanded"),overlay.setCoveredState(!1),overlay.isExiting=!0,overlay.exitHoleStart=overlay.hole,overlay.phase="exit",overlay.phaseStart=performance.now(),new Promise(t=>{const e=()=>{overlay&&!overlay.running?(overlay=null,t()):requestAnimationFrame(e)};e()})):Promise.resolve()}export function isImpactLiquidOverlayActive(){return Boolean(overlay)}