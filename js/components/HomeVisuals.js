export const VISUAL_PRESETS={default:{wave:{baseString:"Design in Everything ",frequency:.009,amplitude:30,speed:3e-4},skull:{mouseLookFactor:.05,autoRotationSpeed:5e-4}},minimal:{wave:{baseString:"● ○ ● ○ ",frequency:.006,amplitude:20,speed:2e-4},skull:{mouseLookFactor:.03,autoRotationSpeed:3e-4}}};export class SkullAnimation{constructor(i,e,t={}){this.canvas=i,this.modelPath=e,this.config={mouseLookFactor:.05,dragRotationSpeed:.005,resetDelay:2e3,resetSpeed:.05,autoRotationSpeed:5e-4,...t},this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,200),this.camera.position.set(0,-6,20),this.camera.lookAt(0,0,0),this.renderer=new THREE.WebGLRenderer({canvas:this.canvas,antialias:!0,alpha:!0,powerPreference:"high-performance"}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight);const s=new THREE.AmbientLight(4210752,.8);this.scene.add(s),(new THREE.GLTFLoader).load(this.modelPath,i=>{this.skull=i.scene,this.scene.add(this.skull),this.centerModel(),this.animate()}),this.canvas.addEventListener("pointermove",this.onPointerMove.bind(this)),this.canvas.addEventListener("pointerdown",this.onPointerDown.bind(this)),this.canvas.addEventListener("pointerup",this.onPointerUp.bind(this)),window.addEventListener("resize",this.onWindowResize.bind(this))}centerModel(){const i=(new THREE.Box3).setFromObject(this.skull).getCenter(new THREE.Vector3);this.skull.position.x+=this.skull.position.x-i.x,this.skull.position.y+=this.skull.position.y-i.y,this.skull.position.z+=this.skull.position.z-i.z}updateInteractionTime(){this.lastInteractionTime=performance.now()}onPointerMove(i){if(this.isDragging&&this.updateInteractionTime(),this.pointerX=i.clientX/window.innerWidth*2-1,this.pointerY=-(i.clientY/window.innerHeight*2-1),this.isDragging){const e=i.clientX-this.previousMouseX,t=i.clientY-this.previousMouseY;this.rotationY+=e*this.config.dragRotationSpeed,this.rotationX+=t*this.config.dragRotationSpeed,this.rotationX=Math.max(-Math.PI/3,Math.min(Math.PI/3,this.rotationX)),this.previousMouseX=i.clientX,this.previousMouseY=i.clientY}}onPointerDown(i){this.updateInteractionTime(),this.isDragging=!0,this.canvas.classList.add("dragging"),this.previousMouseX=i.clientX,this.previousMouseY=i.clientY}onPointerUp(){this.canvas.classList.remove("dragging"),this.isDragging=!1}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)}animate(i=0){const e=i-this.lastFrameTime,t=i-this.lastInteractionTime;this.skull&&(this.isDragging?(this.skull.rotation.y=this.rotationY+this.pointerX*this.config.mouseLookFactor,this.skull.rotation.x=this.rotationX+this.pointerY*this.config.mouseLookFactor):(this.skull.rotation.y=this.rotationY+i*this.config.autoRotationSpeed,this.skull.rotation.x=this.rotationX,t>this.config.resetDelay&&(this.rotationX*=1-this.config.resetSpeed*(e/16.67)))),this.renderer.render(this.scene,this.camera),this.lastFrameTime=i,this.animationFrameId=requestAnimationFrame(i=>this.animate(i))}destroy(){this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.canvas.removeEventListener("pointermove",this.onPointerMove),this.canvas.removeEventListener("pointerdown",this.onPointerDown),this.canvas.removeEventListener("pointerup",this.onPointerUp),window.removeEventListener("resize",this.onWindowResize),this.skull&&(this.scene.remove(this.skull),this.skull.traverse(i=>{i.geometry&&i.geometry.dispose(),i.material&&(Array.isArray(i.material)?i.material.forEach(i=>i.dispose()):i.material.dispose())})),this.renderer.dispose()}}