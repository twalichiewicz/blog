<div id="postsContent" class="blog-list" role="tabpanel" aria-labelledby="tab-blog">
    <div class="column-title blog-column-title">Posts</div>
    
    <!-- Add search bar -->
    <div class="search-container">
        <div class="search-input-wrapper">
            <div class="search-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 21l-4.35-4.35"/>
                    <path d="M15.5 10.5a5 5 0 1 0-10 0 5 5 0 0 0 10 0z"/>
                </svg>
            </div>
            <input type="text" id="postSearch" placeholder="Search words..." class="search-input" aria-label="Search blog posts">
            <button class="search-clear" aria-label="Clear search" style="display: none;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <button class="posts-only-button" data-filter="posts"><span class="button-text-full">Posts only</span></button>
    </div>
    
    <% if (blogPosts.length > 0) { %>
        <% blogPosts.forEach(function(post, index) { %>
            <% 
            // Generate unique post ID from title or use index
            const postId = 'post-' + (post.slug || post.title.toLowerCase().replace(/[^\w]+/g, '-') || index);
            
            // Determine if this is a long-form post (has <a> in h3 and long: true)
            const isLongPost = post.long === true && !post.type;
            const classNames = [];
            if (post.type === 'link') {
                classNames.push('post-link');
            }
            if (isLongPost) {
                classNames.push('post-long');
            }
            %>
            <% 
            // Check if this is a regular blog post (not link or short)
            const isRegularPost = !post.type && !post.short;
            %>
            
            <% if (isRegularPost) { %>
                <%# Use the Substack-style post-link partial for regular posts %>
                <%- partial('post-link', { post: post }) %>
            <% } else { %>
                <%# Keep existing rendering for link posts and short posts %>
                <% if (isLongPost) { %>
                    <a href="<%- url_for(post.path) %>" class="post-link-wrapper no-external-indicators">
                <% } %>
                <article class="post-list-item <%= classNames.join(' ') %>" id="<%= postId %>">
                    <div class="post-byline">
                        <%= date(post.date, 'MMMM D, YYYY') %> • 
                        <%= post.type === 'link' ? 'Link' : (post.short ? 'Musing' : 'Post') %>
                    </div>
                    <% if (post.type === 'link') { %>
                        <div class="link-share no-external-indicators">
                            <% if (post.content) { %>
                                <% 
                                // Strip script tags from link post content to prevent HTML breaking
                                const cleanContent = post.content
                                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                                    .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
                                %>
                                <p><%- cleanContent %></p>
                            <% } %>
                            
                            <a href="<%= post.url %>" target="_blank" rel="noopener" class="post-list-item post-long post-link-wrapper <%= post.workspace_os_special ? 'workspace-os-starfield' : '' %>">
                                <% if (post.workspace_os_special) { %>
                                    <canvas class="starfield-canvas"></canvas>
                                    <style>
                                    /* WorkspaceOS starfield styling - always dark mode */
                                    .workspace-os-starfield,
                                    [data-theme="light"] .workspace-os-starfield,
                                    [data-theme="dark"] .workspace-os-starfield {
                                        position: relative;
                                        background: radial-gradient(ellipse at center, #0B1426 0%, #050B1A 70%, #000205 100%) !important;
                                        overflow: hidden;
                                        border: 1px solid rgba(255, 255, 255, 0.1) !important;
                                        min-height: 80px;
                                    }
                                    .starfield-canvas {
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        width: 100%;
                                        height: 100%;
                                        pointer-events: none;
                                    }
                                    .workspace-os-starfield .link-text-group,
                                    [data-theme="light"] .workspace-os-starfield .link-text-group,
                                    [data-theme="dark"] .workspace-os-starfield .link-text-group {
                                        color: white !important;
                                        position: relative;
                                        z-index: 2;
                                    }
                                    .workspace-os-starfield .link-url,
                                    [data-theme="light"] .workspace-os-starfield .link-url,
                                    [data-theme="dark"] .workspace-os-starfield .link-url {
                                        color: rgba(255, 255, 255, 0.7) !important;
                                    }
                                    .workspace-os-starfield .external-icon,
                                    [data-theme="light"] .workspace-os-starfield .external-icon,
                                    [data-theme="dark"] .workspace-os-starfield .external-icon {
                                        color: white !important;
                                        background: rgba(255, 255, 255, 0.1) !important;
                                        border-color: rgba(255, 255, 255, 0.2) !important;
                                    }
                                    .workspace-os-starfield:hover .external-icon,
                                    [data-theme="light"] .workspace-os-starfield:hover .external-icon,
                                    [data-theme="dark"] .workspace-os-starfield:hover .external-icon {
                                        background: rgba(255, 255, 255, 0.2) !important;
                                        border-color: rgba(255, 255, 255, 0.3) !important;
                                    }
                                    /* Ensure hover states also maintain dark styling */
                                    .workspace-os-starfield:hover,
                                    [data-theme="light"] .workspace-os-starfield:hover,
                                    [data-theme="dark"] .workspace-os-starfield:hover {
                                        background: radial-gradient(ellipse at center, #0B1426 0%, #050B1A 70%, #000205 100%) !important;
                                    }
                                    </style>
                                    <script>
                                    (function() {
                                        const container = document.querySelector('.workspace-os-starfield');
                                        const canvas = document.querySelector('.workspace-os-starfield .starfield-canvas');
                                        if (!canvas || !container) return;
                                        
                                        const ctx = canvas.getContext('2d');
                                        let stars = [];
                                        const starCount = 35;
                                        let isWarping = false;
                                        let isReturning = false;
                                        let fadeOpacity = 1;
                                        let warpProgress = 0; // 0 to 1 for logarithmic curve
                                        let targetWarpProgress = 0;
                                        const maxWarpSpeed = 15; // Reduced from 50 for less chaos
                                        const warpAcceleration = 0.08; // Slower acceleration
                                        
                                        function createStar(rect) {
                                            // Create star with random distribution
                                            const x = Math.random() * rect.width;
                                            const y = Math.random() * rect.height;
                                            
                                            return {
                                                x: x,
                                                y: y,
                                                originX: x,
                                                originY: y,
                                                baseSize: 0.3 + Math.random() * 0.7,
                                                twinkleSpeed: 0.5 + Math.random() * 1.5,
                                                twinkleOffset: Math.random() * Math.PI * 2,
                                                brightness: 0.6 + Math.random() * 0.4,
                                                speed: 0.3 + Math.random() * 0.7, // Reduced speed range
                                            };
                                        }
                                        
                                        function setupCanvas() {
                                            const rect = canvas.getBoundingClientRect();
                                            const dpr = window.devicePixelRatio || 1;
                                            
                                            canvas.width = rect.width * dpr;
                                            canvas.height = rect.height * dpr;
                                            
                                            ctx.scale(dpr, dpr);
                                            
                                            // Create stars with random distribution
                                            stars = [];
                                            for (let i = 0; i < starCount; i++) {
                                                stars.push(createStar(rect));
                                            }
                                        }
                                        
                                        function animate() {
                                            const rect = canvas.getBoundingClientRect();
                                            const centerX = rect.width / 2;
                                            const centerY = rect.height / 2;
                                            
                                            // Clear or fade based on warp state
                                            if (isWarping || warpProgress > 0.01) {
                                                ctx.fillStyle = 'rgba(5, 11, 26, 0.4)';
                                                ctx.fillRect(0, 0, rect.width, rect.height);
                                            } else {
                                                ctx.clearRect(0, 0, rect.width, rect.height);
                                            }
                                            
                                            const time = Date.now() * 0.001;
                                            
                                            // Update warp progress with smooth transition
                                            if (Math.abs(warpProgress - targetWarpProgress) > 0.001) {
                                                warpProgress += (targetWarpProgress - warpProgress) * warpAcceleration;
                                            } else {
                                                warpProgress = targetWarpProgress;
                                            }
                                            
                                            // Calculate actual warp speed using logarithmic curve
                                            // This creates the acceleration feel
                                            const logCurve = warpProgress > 0 ? Math.log(1 + warpProgress * 9) / Math.log(10) : 0;
                                            const warpSpeed = logCurve * maxWarpSpeed;
                                            
                                            // Handle fade effect when returning from warp
                                            if (isReturning) {
                                                fadeOpacity -= 0.05;
                                                if (fadeOpacity <= 0) {
                                                    fadeOpacity = 0;
                                                    // Reset all stars to random positions
                                                    stars.forEach(star => {
                                                        star.x = Math.random() * rect.width;
                                                        star.y = Math.random() * rect.height;
                                                        star.originX = star.x;
                                                        star.originY = star.y;
                                                    });
                                                    isReturning = false;
                                                }
                                            } else if (!isWarping && fadeOpacity < 1) {
                                                fadeOpacity = Math.min(1, fadeOpacity + 0.03);
                                            }
                                            
                                            stars.forEach(star => {
                                                // Move stars during warp
                                                if (warpSpeed > 0.5 && !isReturning) {
                                                    // Calculate direction from center
                                                    const dx = star.x - centerX;
                                                    const dy = star.y - centerY;
                                                    const angle = Math.atan2(dy, dx);
                                                    const speed = star.speed * warpSpeed;
                                                    
                                                    star.x += Math.cos(angle) * speed;
                                                    star.y += Math.sin(angle) * speed;
                                                    
                                                    // Reset star if it goes off screen
                                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                                    if (dist > Math.max(rect.width, rect.height) * 0.7) {
                                                        const newAngle = Math.random() * Math.PI * 2;
                                                        const startDist = 5 + Math.random() * 20;
                                                        star.x = centerX + Math.cos(newAngle) * startDist;
                                                        star.y = centerY + Math.sin(newAngle) * startDist;
                                                    }
                                                }
                                                
                                                // Calculate star appearance
                                                const twinkle = Math.sin(time * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
                                                const warpMultiplier = 1 + (warpSpeed / maxWarpSpeed) * 1.5; // Less extreme size change
                                                const currentSize = star.baseSize * twinkle * warpMultiplier;
                                                const baseOpacity = star.brightness * twinkle * fadeOpacity;
                                                
                                                // Draw star trail during warp
                                                if (warpSpeed > 3 && !isReturning) {
                                                    const trailLength = Math.min(warpSpeed * 3, 30); // Shorter trails
                                                    const dx = star.x - centerX;
                                                    const dy = star.y - centerY;
                                                    const angle = Math.atan2(dy, dx);
                                                    
                                                    // Draw trail with gradient
                                                    const gradient = ctx.createLinearGradient(
                                                        star.x, star.y,
                                                        star.x - Math.cos(angle) * trailLength,
                                                        star.y - Math.sin(angle) * trailLength
                                                    );
                                                    gradient.addColorStop(0, `rgba(255, 255, 255, ${baseOpacity * 0.6})`);
                                                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                                    
                                                    ctx.strokeStyle = gradient;
                                                    ctx.lineWidth = currentSize * 2;
                                                    ctx.lineCap = 'round';
                                                    ctx.beginPath();
                                                    ctx.moveTo(star.x, star.y);
                                                    ctx.lineTo(
                                                        star.x - Math.cos(angle) * trailLength,
                                                        star.y - Math.sin(angle) * trailLength
                                                    );
                                                    ctx.stroke();
                                                }
                                                
                                                // Draw star
                                                ctx.fillStyle = `rgba(255, 255, 255, ${baseOpacity})`;
                                                ctx.beginPath();
                                                ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
                                                ctx.fill();
                                                
                                                // Subtle glow effect
                                                if (star.baseSize > 0.8 && star.brightness > 0.9 && !isReturning) {
                                                    const glowSize = 3 + (warpSpeed / maxWarpSpeed) * 2;
                                                    ctx.fillStyle = `rgba(255, 255, 255, ${baseOpacity * 0.03})`;
                                                    ctx.beginPath();
                                                    ctx.arc(star.x, star.y, currentSize * glowSize, 0, Math.PI * 2);
                                                    ctx.fill();
                                                }
                                            });
                                            
                                            if (document.contains(canvas)) {
                                                requestAnimationFrame(animate);
                                            }
                                        }
                                        
                                        // Hover event handlers
                                        container.addEventListener('mouseenter', () => {
                                            isWarping = true;
                                            isReturning = false;
                                            targetWarpProgress = 1;
                                            fadeOpacity = 1;
                                        });
                                        
                                        container.addEventListener('mouseleave', () => {
                                            isWarping = false;
                                            isReturning = true;
                                            targetWarpProgress = 0;
                                        });
                                        
                                        // Touch support for mobile
                                        container.addEventListener('touchstart', () => {
                                            isWarping = true;
                                            isReturning = false;
                                            targetWarpProgress = 1;
                                            fadeOpacity = 1;
                                        });
                                        
                                        container.addEventListener('touchend', () => {
                                            isWarping = false;
                                            isReturning = true;
                                            targetWarpProgress = 0;
                                        });
                                        
                                        // Setup and start
                                        setupCanvas();
                                        animate();
                                        
                                        // Handle resize
                                        let resizeTimeout;
                                        window.addEventListener('resize', () => {
                                            clearTimeout(resizeTimeout);
                                            resizeTimeout = setTimeout(() => {
                                                setupCanvas();
                                            }, 100);
                                        });
                                    })();
                                    </script>
                                <% } %>
                                <div class="link-text-group">
                                    <%= post.title %>
                                    <div class="link-source">
                                        <span class="link-url"><%= new URL(post.url).hostname %></span>
                                    </div>
                                </div>
                                <span class="external-icon">↗</span>
                            </a>
                        </div>
                    <% } else if (post.short) { %>
                        <%- post.content %>
                    <% } %>
                </article>
                <% if (isLongPost) { %>
                    </a>
                <% } %>
            <% } %>
            <% if (index < blogPosts.length - 1) { %>
                <hr class="post-separator">
            <% } %>
        <% }) %>
    <% } else { %>
        <!-- No posts to display -->
    <% } %>
</div>